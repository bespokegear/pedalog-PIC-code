/********************************************************************
 FileName:		user.c
 Dependencies:	See INCLUDES section
 Processor:		PIC18 or PIC24 USB Microcontrollers
 Hardware:		Pedalog User Program
				This code reads in data from the analogue inputs (in main.c)
				This data is the current and the voltage generated by a device
				See schematic for details (******final schematic******)
				The data is processed to show power and energy.
				There are two switches which control the user interface
				There is an LCD output and an SPI output 
				The device connects via USB using the microchip usb driver (which must be installed)

 Complier:  	Microchip C18 (for PIC18) or C30 (for PIC24)
 Company:       Microchip Technology, Inc.
				Renewable Energy Innovation	

 *
 * Software License Agreement

 The software supplied herewith by Microchip Technology Incorporated
 (the “Company”) for its PIC® Microcontroller is intended and
 supplied to you, the Company’s customer, for use solely and
 exclusively on Microchip PIC Microcontroller products. The
 software is owned by the Company and/or its supplier, and is
 protected under applicable copyright laws. All rights are reserved.
 * Any use in violation of the foregoing restrictions may subject the
 * user to criminal sanctions under applicable laws, as well as to
 * civil liability for the breach of the terms and conditions of this
 * license.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.

********************************************************************
 File Description:

 Change History:
  Rev   Date         Description
  1.0   11/19/2004   Initial release
  2.1   02/26/2007   Updated for simplicity and to use common
                     coding style
  3.0	24/11/2009	 Matt Little updated
  4.0	14/9/2010	 Matt Little code updated - lots of changes\
  5.0	23/12/2010	 Matt Little code cleaned up and notes added	
		
********************************************************************/

/** INCLUDES *******************************************************/
#include "Compiler.h"
#include "GenericTypeDefs.h"
#include "HardwareProfile.h"
#include "usb_config.h"
#include "USB/usb_device.h"
#include "USB/usb.h"
#include "USB/usb_function_generic.h"
#include "user.h"
#include <p18cxxx.h>
#include <stdlib.h>
#include <delays.h>
#include <stdio.h>
#include ".\xlcd.h"
#include "max7219matt.h"
#include <spi.h>

//*****************************************************************************/
/**********USER INPUTS - CHANGE FOR DIFFERENT VERSIONS*************************/
/*********This section is for the different versions***************************/
/*********Change this data and then recompile for the specific project*********/

//*************BACKLIGHT VERSION?**********************************************/
rom BOOL backlight_flag=TRUE;		// TRUE = there is a backlight, FALSE = there is NO backlight

//*************Display Update Time in Number of samples***************************************/
const rom int sample_freq=2000;  // This is the sampling frequency in Hz (how often data is read)
const rom int max_count_HISR=2000;  // This is the averaging period in terms of numbers of samples. 
// The sample rate is 2kHz. Hence 1000 gives an update of 0.5s, 2000 = 1s etc. 
// Use a maximum value of 4000 (2s) or else the values might overflow
// This value is stored in program memory as it will not change once programmed
// The MAX this value can be is 15887 (around 8seconds) or else problems with overflow data in long integers

// *********************I and V COMPONENT VALUES*******************************/
// *****************V POTENTIAL DIVIDER COMPONENT VALUES***********************/
double V_R16_val=56.0;		// The value of resistor R16 (part of the potential divider) in 10's kilo ohms
double V_R17_val=4.7;		// The value of resistor R17 (part of the potential divider) in 10's kilo ohms
// *****************V POTENTIAL DIVIDER COMPONENT VALUES***********************/
double I_gain=20;			// This is the gain of the INA168 current chip. With 100K the gain is 20
double R_mOhm_shunt=10;	// This is the value of the shunt resistor in milli ohms

//***************** SPI DISPLAY ***********************************************//
//*** This is the basic design which will show either power or energy on ******//
//*** The SPI bus. Refer to the circuit diagram for connection details ********// 
ram int	SPIdisplayflag=0;	// With this set to 0 = POWER, 1 = ENERGY, 2 = TEST COUNTER

//***************** SERIAL NUMBER ***********************************************//
//*** This is a code to distinguish each pedalog device - change for each device ******//
//*** Refer to the pedalog device list for more info ********// 
ram char serial_str[5]={'9','9','9','9','\0'};

/*************************END OF USER INPUTS***********************************/

//*****************************************************************************/
/******************************************************************************/

int d=0;	// test integer

/************** V A R I A B L E S ************************************************/
#pragma udata
BYTE counter;

#if defined(__18F14K50) || defined(__18F13K50) || defined(__18LF14K50) || defined(__18LF13K50) 
    #pragma udata usbram2
#elif defined(__18F2455) || defined(__18F2550) || defined(__18F4455) || defined(__18F4550)\
    || defined(__18F2458) || defined(__18F2453) || defined(__18F4558) || defined(__18F4553)
    #pragma udata USB_VARIABLES=0x500
#elif defined(__18F4450) || defined(__18F2450)
    #pragma udata USB_VARIABLES=0x480
#else
    #pragma udata
#endif

DATA_PACKET INPacket;			// These are used for the USB
DATA_PACKET OUTPacket;

// ********This is where the global user variables will be defined*****//
// *********MUST ALSO ADD EXTERN REF TO TOP OF main.c******************//
			
#pragma udata				
ram char VoltStr[5]={'\0'};				// This is the voltage as a string xx.x to send back
ram char I_out_Str[6]={'\0'};			// This is the current out as a string XX.X to send back	
ram char P_O_Str[6]={'\0'};				// This is the Power as a string XXXX.X to send back
ram char P_Ave_Str[6]={'\0'};			// This is the Power as a string XXXX.X to send back
ram char P_Max_Str[6]={'\0'};			// This is the cumulative energy to send back
ram char E_O_Str[8]={'\0'};				// This is the cumulative energy to send back
ram char E_O_Str_disp[8]={'\0'};		// This is the energy to display 
ram char total_run_time_s_str[9]={'\0'};// This is the full run time
ram char temp_run_time_s_str[8]={'\0'};	// This is the temporary time
ram char Money_Str[8]={'\0'};			// This is the cumulative Money to send back

//***************Temp Values***************************************//

int reset_temp_flag=3;	// This is a flag to tell the LISR to reset the temp values (depends upon switches pressed)

int LCD_ramp_up=FALSE;			// This is a flag to ramp up the LCD backlight
int voltage_applied=FALSE;		// This is a flag to indicate voltage applied
unsigned long int LCD_backlight_counter=0;	// A counter for the LCD backlight delay
unsigned long int LCD_backlight_max=1000000;		// The maximum count for the LCD backlight delay (switch OFF after this delay if no swicth press)

int update_display=TRUE;	// This tells the LISR to update the display on start up
int	switch_mode=1;			// This is a value for the switch 1 state diagram

int display_mode=1;			// This is a value to decide which value to show on the LCD display (in this case: MONEY)
int	max_display_mode=8;		// This is the total number of display modes (so the value can roll around and reset)
int buzzer_flag=FALSE;		// This is a flag to set off the buzzer for a small beep

double M_conv=0;			// This is the money conversion value recalled from the EEPROM

int	counter1=0;
int	counter2=0;
unsigned long int switchcounter1=0;
unsigned long int switchcounter2=0;
unsigned long int LCD_off_counter=0;
int switchcounter3=0;
BOOL switchreset=TRUE;
BOOL change_value=TRUE;

BOOL adjustment_flag=FALSE;	// For the switch routine
int switch_pressed=0;	// To tell the routine which was the last switch pressed

//*************DEBUG MODE*************************************************************
rom BOOL debug=FALSE;		// This is a variable which allows me to enter debug mode
//rom BOOL debug=TRUE;		// It removes all the LCD functions which stop the MPLAB SIM
//************************************************************************************

#pragma romdata	eedata_scn=0xf00010
rom float eeprom_data=0;		// This writes a value of 0 to the eeprom when the device is first written to.
#pragma romdata

//***************END OF USER DEF GLOBAL VARIABLES**********************//


#pragma udata
USB_HANDLE USBGenericOutHandle = 0;
USB_HANDLE USBGenericInHandle = 0;
BOOL blinkStatusValid = TRUE;

/** P R I V A T E  P R O T O T Y P E S ***************************************/

void BlinkUSBStatus(void);
void ResetTempLog(void);
void ServiceRequests(void);
void mInitInterrupts(void);
void DelayFor18TCY( void );
void DelayPORXLCD( void );
void DelayXLCD( void );
unsigned char readEE(unsigned char addr);
float readEE_float(unsigned char address);
void writeEE(unsigned char address, char data);
void writeEE_float(unsigned char address, float data);

/** D E C L A R A T I O N S **************************************************/
#pragma code

/******* LCD DEFINITIONS ******************************************/
const rom char dataArrayInit[17]={' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','\0'};


/****************CONVERSION FACTORS********************************/

float V_conversion=0;	// This is the conversion value used to calculate the voltage (also used in main.c)
float I_conversion=0;	// This is the conversion value used to calculate the voltage (also used in main.c)
float P_conversion=0;	// This is the conversion value used to calculate the Power (also used in main.c)
float E_conversion=0;	// This is the conversion value used to calculate the Energy (also used in main.c)
float M_conversion=0;	// This is the conversion value used to calculate the Money (also used in main.c) 

/**************Initialise interrupts****************/
void mInitInterrupts(void)
{
	RCONbits.IPEN=1; 		// Set priority levels for interrupts

	// 1 Firstly set up the high priority interrupt service routine
	INTCONbits.TMR0IE = 1;	// Interrupt control register: Enable TMR0 Overflow interrupt bit	
	INTCON2bits.TMR0IP = 1;	// INTCON 2: Set TMR0 priority to HIGH
	T0CONbits.TMR0ON = 1;	// Timer0 Control reg: Enable Timer0	
	T0CONbits.T08BIT = 0;	// Timer0 Control reg: Set timer 0 as 16bit 
	T0CONbits.T0CS = 0;		// Timer0 Control reg: Internal instruction Clock
	T0CONbits.PSA = 1;		// Timer0 Control reg: Prescaler NOT used
	TMR0H = 0xF7; // Load TIMER0 with a value - makes delay shorter - (5000Hz samples) 0.2mS with these values (48MHz/4 clock)
	TMR0L = 0x52; // Load TIMER0 with a value - makes delay shorter 
	INTCONbits.TMR0IF = 0;	// Timer0 Overflow flag: Set to zero
	
	// 2 Set up the low priority interrupt service routine
	T2CON = 0b00000111;  	// Initialise TIMER2, TIMER ON and PRESCALER=16
	IPR1bits.TMR2IP = 0; 	// Set priority to LOW
	PIE1bits.TMR2IE = 1;	// Enable TIMER2 interrupts

	// 3 Enable the interrupts
	INTCONbits.GIEL = 1;	// Interrupt control register: Enable Global Interrupt Enable bit
	INTCONbits.GIE = 1;		// Interrupt control register: Enable Global Interrupt Enable bit

}//end Initialise interrupts routine

/**************Initialise LCD****************/
void mInitLCD(void)
{
	// Initialise LCD for 4 bit operation and multiple line operation
	OpenXLCD( FOUR_BIT & LINES_5X7 );	// configure external LCD

	// Initialise display so that neither cursor nor blink is ON
	while(BusyXLCD());
	WriteCmdXLCD(0b00000001);			// Reset Display

	// Initialise display so that neither cursor nor blink is ON
	while(BusyXLCD());
	WriteCmdXLCD(0b00001100);			// Last three digits are display ON, Cursor OFF, Blink OFF

	// Initialise display as what to show:
	// Money:XXXXXXXp
	// Energy:XXXXXWh
	while(BusyXLCD());
	SetDDRamAddr( 0x00 );		// Put the cursor in the correct position

	//Blank the bottom line, just in case
	while(BusyXLCD());
	putrsXLCD(dataArrayInit);	
	
	while(BusyXLCD());
	SetDDRamAddr( 0x40 );		// Put the cursor in the correct position

	//Blank the bottom line, just in case
	while(BusyXLCD());
	putrsXLCD(dataArrayInit);	

}//end Initialise LCD routine

/**************Initialise Conversion Values****************/
void mInitConversion(void)
{
	// I conversion is calculated from:
	// The max input is 5V. This equates to a reading of 1024.
	// The value read will be the sum of all the currents which must be divided by the number of counts done (max_count_HISR)
	// So the read value will be Isum/max_count_HISR.
	// This value is out of 1024 (10 bit)
	// The I_shunt_conv is the maximum current to read at 5V
	// There is a an internal gain on the current sensor - with 100K this is 20 times (check INA168 datasheet).
	// So at 5V input the current will be the value of I_shunt_conv
	// Hence the calculation is:
	// Iactual = Ireading x (I_shunt_conv /(max_count_HISR x 1024))
	// To convert this into the correct value for the display (2 decimal points) it needs to be multiplied by 100.
	// The I_shunt_conv value comes from the maximum current at 5V
	// This is calculated by:
	// V=IR
	// Where V =5V divided by I_gain, R= shunt in milliohms
	// Hence maximum I at 5V = (5*1000)/(I_gain*R_mOhm_shunt)

	//I_conversion = (I_shunt_conv*100)/((float)max_count_HISR*1024);		// This is CORRECT

	I_conversion = (((5*1000)/(I_gain*R_mOhm_shunt))*100)/((float)max_count_HISR*1024);

	// V conversion is calculated from:
	// V input is decided from the potential divider.
	// The Vreading is V_sum divided by max_count_HISR 
	// This is converted into a voltage by dividing by 1024 and multiplying by 5V.
	// Voltage input is: (V_sum / max_count_HISR) x (5/1024)
	// Hence the calclation is:
	// Vactual = (V_sum / max_count_HISR) x (5/1024) x ((R16+R17)/R16)
	// To convert this into the correct value for the display (2 decimal points) it needs to be multiplied by 100.
	V_conversion=(((float)V_R16_val+(float)V_R17_val)*5*100)/((float)V_R17_val*(float)max_count_HISR*1024); // Calc Voltage conversion factor	

	// The Power conversion is just the multiple of both of them...	
	// But then there is one too many max_count_HISR divisions so we remove them and also get correct factor todisplay resolution (divide by 100)
	P_conversion=(V_conversion*I_conversion*(float)max_count_HISR)/100;  

	// The Energy conversion value depends upon the number of counts per sample period.
	// Cumulative Energy = power x sample period
	// Data is read at 2000Hz hence why each value is for (max_count_HISR/2000)s 
	// Convert Ws into Wh to give actual energy. 
	// Ws to Wh means divide by 3600 (60x60) 
	// but power also has a factor of 100 included so must also cancel this (hence 360000).
	E_conversion= (float)max_count_HISR/sample_freq/360000;

}//end Initialise Conversion Values routine

/**************Initialise SPI interface for LED driver****************/
void mInitSPI(void)
{
	MAX7219Init();	
			
}//end Initialise SPI routine


/**************Initialise EEPROM Values****************/
void mInitEEPROM(void)
{

	M_conv=readEE_float(0x10);
	// The money conversion is from the p per kWh
	// Energy x M_conv /1000 = actual cost in pence.
	// This is multiplied by 100 to give the reading in 0.00p ...
	// Hence calculation is:
	// Evalue x M_conv X 100 /1000 (same as dividing by 10)
	M_conversion = M_conv/10;

}//end Initialise EEPROM Values routine


//*****************************************************************************//


//********************** User initialiseation routine**************************//
//***************Called from the Initialisation rotuine in main.c**************//

void UserInit(void)
{
	mInitConversion();	// Initialise all the conversion values required for ISR maths
    mInitAllSwitches();	// Initislise the switches in accordance to the hardware profile
	mInitEEPROM();		// Read in any saved values from EEPROM
    mInitAllLEDs();		// Initialise the LEDs in acordance to the hardware profile	
	mLCD_power_init();	// initialise the LCD backlight
 	mInitDAQ();			// Initialise the Data Acquisition parameters (AN inputs etc)
	if (debug==FALSE)
	{
		mInitLCD();			// Must comment this out when testing as LCD will never initialise...
	}
	mInitSPI();			// Initialise the SPI interface for talking to the LED driver (must be after the LCD)
    mInitInterrupts();	// Initialise the interrupts/timers etc
	if(backlight_flag==TRUE)
	{
		LCD_ramp_up=TRUE;		// turn on the LCD back light
	}	
}//end UserInit


/******************************************************************************
 * Function:        void ProcessIO(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        This function is a place holder for other user routines.
 *                  It is a mixture of both USB and non-USB tasks.
 *
 * Note:            None
 *****************************************************************************/
void ProcessIO(void)
{   
    //**********Blink the LEDs according to the USB device status****************
    if(blinkStatusValid)
    {
        BlinkUSBStatus();
    }

	//****************Main background code goes here**************************
	// This code runs if there is neither a HISR nor a LISR
	// This cannot be timed data but should still run at a reasonable speed

	//*********switch ON the backlight if a voltage is applied (in all circumstances)****************
	//**********also deal with the backlight counter - count up and ramp down the light when done****
	if(backlight_flag==TRUE)	// only do this if the backlight is enabled
	{
		if(voltage_applied==TRUE)	// only do this if the backlight is there
		{
			LCD_ramp_up=TRUE;
			LCD_backlight_counter=0;
		}
		else
		{
			LCD_backlight_counter++;
		}

		if(LCD_backlight_counter>=LCD_backlight_max)
		{
			// While here also count up for the backlight delay rountine
			// If an buttons are pressed then reset the counter to wait
			// Counter will have quite big numbers in it as this will run quickly
			// Want to set this delay in approx seconds - might need more counters?
			LCD_ramp_up=FALSE;
			LCD_backlight_counter=0;
		}
	}

	//************* CHECK BUTTONS - HAVE ANY BEEN PRESSED?*******************************
	// This routine checks the switches. If one has been pressed there is a delay loop to ensure that it is
	// a positive press and to debounce. 
	switch(switch_mode)
	{
		case 1:
		{			
			//Is either button pressed?		
			//N return to 1
			//Y goto state 2
			if(sw1 || sw2 == TRUE)
			{	
				switch_mode=2;
			}
		}
		break;
		
		case 2:
		{
			// Wait 0.1ish seconds (debouce) 	
			// Goto state 3
			counter1++;
			if(counter1>= 5000)	// Just a short counter to do a debouce
			{
				counter1=0;
				switch_mode=3;
			}
		}
		break;

		case 3:
		{
			// Is a button pressed?
			// Look up SW0 and SW1 chart:
			// SW0 SW1
			//	0	0	Return to 1
			//	1	0	If adjustment_flag is TRUE goto state 7
			//			Else Goto state 4 - scroll through values
			//	0   1	If adjustment_flag is TRUE goto state 7
			//			Else Goto state 10 - start/stop the hold values
			// 	1	1	If adjustment_flag is TRUE goto state 8
			//			Else Goto state 6
			
			if(sw1==FALSE && sw2==FALSE)
			{
				switch_mode=1;		// No button pressed hence return to waiting for button press
				break;
			}

			// Is the LCD backlight on already? Does it need to be on?
			if(backlight_flag==TRUE)	// only do this if the backlight is there
			{
				if(LCD_ramp_up==FALSE)
				{
					switch_mode=11;
					break;
				}
			}

			if ((sw1==TRUE&&sw2==FALSE))  // 1 0 pressed 
			{
				buzzer_flag=TRUE;		// Beep the buzzer

				if(adjustment_flag==TRUE)
				{
					switch_mode=7;	// adjust value up/down
				} else {
					switch_mode=4;	// scroll up/down	
				}
			}
			else if ((sw1==FALSE&&sw2==TRUE))  // 0 1 pressed 
			{
				buzzer_flag=TRUE;		// Beep the buzzer
				if(adjustment_flag==TRUE)
				{
					switch_mode=7;	// adjust value up/down
				} else {
					switch_mode=10;	// enter start/stop mode
				}
			}
			else if (sw1==TRUE&&sw2==TRUE)	// Both sw1 and sw2 pressed - enter or leave adjustment mode
			{
				buzzer_flag=TRUE;		// Beep the buzzer
				if(adjustment_flag==TRUE)
				{
					switch_mode=8;		// leave adjustment mode
				} else {
					switch_mode=6;		// Enter adjustment mode
				}			
			}
	
			LCD_backlight_counter=0;	// This resets the LCD backlight counter when a button has been pressed
		}
		break;

		case 4:
		{
			//If SW0 = 1 then scroll up (increment display counter)
			//If SW1 = 1 then scroll down (decrement display counter)
			//Goto state 5
			if(sw1==TRUE)
			{
				display_mode++;
				if(display_mode>max_display_mode)
				{
					display_mode=1;
				}
				switch_pressed=1;	// Tells case 5 which switch was previously pressed
			}
			if(sw2==TRUE)
			{
				display_mode--;
				if(display_mode<=0)
				{
					display_mode=max_display_mode;
				}
				switch_pressed=2;	// Tells case 5 which switch was previously pressed
			}
			update_display=TRUE;
			switch_mode=5;	// Go to the delay to stop scrolling through too quickly
		}
		break;

		case 5:
		{
			//Count for 0.5s – this is to stop scrolling through too quickly.
			//During this:
			//If the switch changes from 1 to zero then goto state 1
			//At the end
			//Goto state 1
			counter1++;
			if(counter1>= 30000)	// Counter to stop things scrolling through too quickly
			{
				counter1=0;
				switch_mode=1;
			}
			if(switch_pressed==1&&sw1==FALSE)	// This is the case if sw1 is released, do not need the counter
			{
				counter1=0;			//	reset the counter
				switch_pressed=0;	//  reset the switch_pressed
				switch_mode=1;		//  return from this case as switch released
			}
			if(switch_pressed==2&&sw2==FALSE)	// This is the case if sw2 is released, do not need the counter
			{
				counter1=0;			//	reset the counter
				switch_pressed=0;	//  reset the switch_pressed
				switch_mode=1;		//  return from this case as switch released
			}
		}
		break;

		case 6:
		{
			//Entered this state to do adjustments
			//Want to check what display mode we are in and do things accordingly
			//Have all the display_modes here:
			//0
			//Set adjustment_flag = TRUE
			//1
			//Set adjustment_flag = FALSE
			//2
			//3… etc
			//Goto state 5

			switch (display_mode)		// There must be as many cases here as there are display modes which allow adjustment
			{	

				case 8:
				{
					// Adjustment allowed
					adjustment_flag=TRUE;  // In case of a problem then set everything to normal and return to mode 1
					switch_mode=9;	// wait for person to let go of buttons  
				}
				break;

				default:
				{
					// Display: Adjustment not allowed
					adjustment_flag=FALSE;  // In case of a problem then set everything to normal and return to mode 1
					switch_mode=9;	// wait for person to let go of buttons  
				}
				break;
			}
		}
		break;

		case 7:
		{
			//Enter this mode to increment any conversion factors
			//Have all the display_modes which can be adjusted here:
			switch (display_mode)		// There must be as many cases here as there are display modes which allow adjustment
			{	
				case 8:			// Adjust the Cost_conv
				{
					if(sw2==TRUE)
					{
						//********ramp up the value****************
						M_conv=M_conv+0.5;
						if(M_conv>=99.9)
						{
							M_conv=99.9;	// Stops the value going too high
						}			
						switch_pressed=1;	// Tells case 5 which switch was previously pressed
					}
					if(sw1==TRUE)
					{
						//********ramp down the value****************
						M_conv=M_conv-0.5;
						if(M_conv<=0)
						{
							M_conv=0;	// Stops the value going too low
						}
						switch_pressed=2;	// Tells case 5 which switch was previously pressed
					}

					/* This is where the value is written to EEPROM - stop interrupts for this time to ensure it works */

					INTCONbits.GIE = 0;				// Disable global interrupt bit

					writeEE_float(0x10,M_conv);		//Store the new value to EEPROM so it can be used next time
													// This must be done in the HISR or else there might be an issue
													// This could be done by having a flag and doing the update in the HISR

					INTCONbits.GIE = 1;				//Enable global interrupt bit

					M_conversion = M_conv/10; 		// Must recaluclate the new conversion value (done in initialisation routine)

					update_display=TRUE;			// Show the new value on the screen
					switch_mode=5;	// Go to the delay to stop scrolling through too quickly  
				}
				break;

				default:
				{
					// Display: Adjustment not allowed some error so leave this state
					adjustment_flag=FALSE;  // In case of a problem then set everything to normal and return to mode 1
					switch_mode=9;	// wait for person to let go of buttons  
				}
				break;
				update_display=TRUE;  // Want to do this here.
			}

		}
		break;

		case 8:
		{
			//Set adjustment_flag = FALSE
			//Goto state 5
			// Entered here as user has wanted to leave adjustment mode			

			// Display displaying mode on top line
			// update_display=TRUE;
			adjustment_flag=FALSE;	// Set the adjustment flag FALSE as leaving that mode

			//Wait here until both buttons are released. 
			if(sw1==FALSE&&sw2==FALSE)
			{
				switch_mode=5;
			}
		}
		break;

		case 9:
		{
			// Entered here as user has wanted to enter adjustment mode			
			// ***********TO DO********************
			// Display adjustment mode on top line, if adjustment flag is set

			//Wait here until both buttons are released. 
			if(sw1==FALSE&&sw2==FALSE)
			{
//				update_display=TRUE;
				switch_mode=5;
			}
		}
		break;

		case 10:
		{
			// Entered here as user has wanted start/stop the timer for pedalling		

			buzzer_flag=TRUE;		// Beep the buzzer
			reset_temp_flag++;		// This increments the reset flag to ensure the main loop does the correct thing
			if(reset_temp_flag==4)	// 0=nothing, 1=reset, 2=nothing, 3=hold values
			{
				reset_temp_flag=0;
			}
			switch_mode=5;
			
		}
		break;

		case 11:
		{
			// entered here as it was the first time a switch was pressed and the backlight was set true
			buzzer_flag=TRUE;		// Beep the buzzer
			LCD_ramp_up=TRUE;
			//first_sw_press=FALSE;
			LCD_backlight_counter=0;
			switch_mode=5;		// first button pressed hence return to waiting for next button press
		}
		break;

		default:
		{
                Nop();
		}
        break;
	}

    // User Application USB tasks
    if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1)) return;

    //respond to any USB commands that might have come over the bus			
    ServiceRequests();

}//end ProcessIO


/******************************************************************************
 * Function:        void ServiceRequests(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    USB traffic can be generated
 *
 * Overview:        This function takes in the commands from the PC from the
 *                  application and executes the commands requested
 *
 * Note:            None
 *****************************************************************************/
void ServiceRequests(void)
{
    BYTE index;
    
    //Check to see if data has arrived
    if(!USBHandleBusy(USBGenericOutHandle))
    {        
        //if the handle is no longer busy then the last
        //transmission is complete
       
        counter = 0;

        INPacket.CMD=OUTPacket.CMD;
        INPacket.len=OUTPacket.len;

        //process the command
        switch(OUTPacket.CMD)
        {
            case READ_VERSION:
	                //dataPacket._byte[1] is len
	                INPacket._byte[2] = MINOR_VERSION;
	                INPacket._byte[3] = MAJOR_VERSION;
	                counter=0x04;
                break;

           case RD_SERIAL:
                {
					//***********Case to read the serial number of the pedalog device**********//
                    INPacket._byte[1] = serial_str[0];
                    INPacket._byte[2] = serial_str[1];
                    INPacket._byte[3] = serial_str[2];
                    INPacket._byte[4] = serial_str[3];
                    counter=0x5;	// This counter must be equal to the size of the data sent plus 1
                }
                break;

            case RD_VOLTS:
				//***********Case to read the voltage when 0x40 sent via USB**********//
				// Voltage is a string XX.X
                    INPacket._byte[1] = VoltStr[0];
                    INPacket._byte[2] = VoltStr[1];
                    INPacket._byte[3] = VoltStr[2];
                    INPacket._byte[4] = VoltStr[3];
                    counter=0x5;	// This counter must be equal to the size of the data sent plus 1
                 
                break;

            case RD_AMPS:
                {
					//***********Case to read the current when 0x41 sent via USB**********//
					// Current is a string XX.XX
                    INPacket._byte[1] = I_out_Str[0];
                    INPacket._byte[2] = I_out_Str[1];
                    INPacket._byte[3] = I_out_Str[2];
                    INPacket._byte[4] = I_out_Str[3];
                    INPacket._byte[5] = I_out_Str[4];

                    counter=0x6;	// This counter must be equal to the size of the data sent plus 1
                }
                break;

           case RD_POWER:
                {
					//***********Case to read the power when 0x42 sent via USB**********//
					// Power is a string XXX.X
                    INPacket._byte[1] = P_O_Str[0];
                    INPacket._byte[2] = P_O_Str[1];
                    INPacket._byte[3] = P_O_Str[2];
                    INPacket._byte[4] = P_O_Str[3];
                    INPacket._byte[5] = P_O_Str[4];

                    counter=0x6;	// This counter must be equal to the size of the data sent plus 1
                }
                break;

           case RD_DATA:
                {
					//***********Case to read back all the data when 0x43 sent via USB**********//

                    INPacket._byte[1] = VoltStr[0];
                    INPacket._byte[2] = VoltStr[1];
                    INPacket._byte[3] = VoltStr[2];
                    INPacket._byte[4] = VoltStr[3];

                    INPacket._byte[5] = I_out_Str[0];
                    INPacket._byte[6] = I_out_Str[1];
                    INPacket._byte[7] = I_out_Str[2];
                    INPacket._byte[8] = I_out_Str[3];
                    INPacket._byte[9] = I_out_Str[4];
					
                    INPacket._byte[10] = P_O_Str[0];
                    INPacket._byte[11] = P_O_Str[1];
                    INPacket._byte[12] = P_O_Str[2];
                    INPacket._byte[13] = P_O_Str[3];
                    INPacket._byte[14] = P_O_Str[4];

                    INPacket._byte[15] = E_O_Str_disp[0];
                    INPacket._byte[16] = E_O_Str_disp[1];
                    INPacket._byte[17] = E_O_Str_disp[2];
                    INPacket._byte[18] = E_O_Str_disp[3];
                    INPacket._byte[19] = E_O_Str_disp[4];
                    INPacket._byte[20] = E_O_Str_disp[5];
                    INPacket._byte[21] = E_O_Str_disp[6];

                    INPacket._byte[22] = P_Max_Str[0];	// MAX POWER
                    INPacket._byte[23] = P_Max_Str[1];
                    INPacket._byte[24] = P_Max_Str[2];
                    INPacket._byte[25] = P_Max_Str[3];
                    INPacket._byte[26] = P_Max_Str[4];

                    INPacket._byte[27] = P_Ave_Str[0];	// AVERAGE POWER
                    INPacket._byte[28] = P_Ave_Str[1];
                    INPacket._byte[29] = P_Ave_Str[2];
                    INPacket._byte[30] = P_Ave_Str[3];
                    INPacket._byte[31] = P_Ave_Str[4];

                    INPacket._byte[32] = total_run_time_s_str[0];	// TIME TAKEN
                    INPacket._byte[33] = total_run_time_s_str[1];
                    INPacket._byte[34] = total_run_time_s_str[2];
                    INPacket._byte[35] = total_run_time_s_str[3];
                    INPacket._byte[36] = total_run_time_s_str[4];
                    INPacket._byte[37] = total_run_time_s_str[5];
                    INPacket._byte[38] = total_run_time_s_str[6];
                    INPacket._byte[39] = total_run_time_s_str[7];

                    INPacket._byte[40] = total_run_time_s_str[0];	// TIME TAKEN
                    INPacket._byte[41] = total_run_time_s_str[1];
                    INPacket._byte[42] = total_run_time_s_str[2];
                    INPacket._byte[43] = total_run_time_s_str[3];
                    INPacket._byte[44] = total_run_time_s_str[4];
                    INPacket._byte[45] = total_run_time_s_str[5];
                    INPacket._byte[46] = total_run_time_s_str[6];
                    INPacket._byte[47] = total_run_time_s_str[7];

                    INPacket._byte[48] = serial_str[0];
                    INPacket._byte[49] = serial_str[1];
                    INPacket._byte[50] = serial_str[2];
                    INPacket._byte[51] = serial_str[3];

                    counter=52;	// This counter must be equal to the size of the data sent plus 1
                }
                break; 
       
            case RESET:
                Reset();
                break;
                
            default:
                Nop();
                break;
        }//end switch()
        if(counter != 0)
        {
            if(!USBHandleBusy(USBGenericInHandle))
            {
                USBGenericInHandle = USBGenWrite(USBGEN_EP_NUM,(BYTE*)&INPacket,counter);
            }
        }//end if
        
        //Re-arm the OUT endpoint for the next packet
        USBGenericOutHandle = USBGenRead(USBGEN_EP_NUM,(BYTE*)&OUTPacket,USBGEN_EP_SIZE);

    }//end if

}//end ServiceRequests

/********************************************************************
 * Function:        void BlinkUSBStatus(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        BlinkUSBStatus turns on and off LEDs 
 *                  corresponding to the USB device state.
 *
 * Note:            mLED macros can be found in HardwareProfile.h
 *                  USBDeviceState is declared and updated in
 *                  usb_device.c.
 *******************************************************************/
void BlinkUSBStatus(void)
{
    static WORD led_count=0;
    
    if(led_count == 0)led_count = 10000U;
    led_count--;

    #define mLED_Both_Off()         {mLED_1_Off();mLED_2_Off();}
    #define mLED_Both_On()          {mLED_1_On();mLED_2_On();}
    #define mLED_Only_1_On()        {mLED_1_On();mLED_2_Off();}
    #define mLED_Only_2_On()        {mLED_1_Off();mLED_2_On();}

    if(USBSuspendControl == 1)
    {
        if(led_count==0)
        {
            mLED_1_Toggle();

//            if(mGetLED_1())
//            {
//                mLED_2_On();
//            }
//            else
//            {
//                mLED_2_Off();
//            }

        }//end if
    }
    else
    {
        if(USBDeviceState == DETACHED_STATE)
        {
 //           mLED_Both_Off();
            mLED_1_On();
        }
        else if(USBDeviceState == ATTACHED_STATE)
        {
//            mLED_Both_On();
        }
        else if(USBDeviceState == POWERED_STATE)
        {
            mLED_1_On();
        }
        else if(USBDeviceState == DEFAULT_STATE)
        {
//            mLED_Only_2_On();
        }
        else if(USBDeviceState == ADDRESS_STATE)
        {
            if(led_count == 0)
            {
                mLED_1_Toggle();

//              mLED_2_Off();

            }//end if
        }
        else if(USBDeviceState == CONFIGURED_STATE)
        {
            if(led_count==0)
            {      
                mLED_1_Toggle(); 
        
//                if(mGetLED_1())
//                {
//                    mLED_2_Off();
//                }
//                else
//                {
//                    mLED_2_On();
//                }

            }//end if
        }//end if(...)
    }//end if(UCONbits.SUSPND...)

}//end BlinkUSBStatus


/******************************************************************************
 * Function:        void TXbyte(BYTE data)
 *
 * PreCondition:    None
 *
 * Input:           BYTE data - send data to the UART(PIC18 only)
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        sends 'data' over the UART
 *
 * Note:            None
 *****************************************************************************/
void TXbyte(BYTE data)
{
    #if defined(__18CXX)
    while(TXSTAbits.TRMT==0);
    TXREG = data;
    #endif
}//end TXbyte


//***********DELAY SUBROUTINES FOR LCD ROUTINES********************//
//***************Fosc = 48Mhz clock *******************************//

void DelayFor18TCY( void )
{
// More than 40uS delay
// 40uS = (48000000/4) = 480 cycles
Delay10TCYx(48); // Delay of 10 x 48 oscillator cycles, same as 20 clock cycles
return;
}

void DelayPORXLCD( void )
{
// Wait more than 15ms after Vcc rises to 4.5V
// 15ms>  180000 = (48000000 x 0.015)/4 cycles at 48MHz
Delay1KTCYx(180); 	//Delay of 15ms
					// Cycles = (TimeDelay * Fosc) / 4
					// Cycles = (15ms * 48MHz) / 4
					// Cycles = 180,000
return;
}

void DelayXLCD( void )
{
// Wait more than 4.1ms 
// 4.1ms> 49200 =  (48000000 x 0.0041)/4 cycles at 48MHz (Use 60000 cycles to be sure)
Delay1KTCYx(60); 	//Delay of 4.1ms
					// Cycles = (TimeDelay * Fosc) / 4
					// Cycles = (4.1ms * 48MHz) / 4
					// Cycles = 50,000
return;
}
/******************************************************************************
 * Function:        float readEE(unsigned char address, float data)
 *
 * PreCondition:    None
 *
 * Input:           address
 *
 * Output:          Float
 *
 * Side Effects:    None
 *
 * Overview:        Reads a Float from the address in EEPROM			
 *
 * Note:            MUST HAVE INTERRUPTS TURNED OFF! - do this in HISR
 *					PROBLEM - this might slow everything down (but only takes 32 cycles normally...)
 *****************************************************************************/
float readEE_float(unsigned char address)
{
	int i;
	float data;
   	for (i = 0; i < 4; i++) 
      	{
			 *((char*)&data + i) = readEE(i + address); 
		}
	return (data);
}


/******************************************************************************
 * Function:        unsigned char readEE(unsigned char addr)
 *
 * PreCondition:    None
 *
 * Input:           addr
 *
 * Output:          char from that address
 *
 * Side Effects:    None
 *
 * Overview:        Reads char from EEPROM at the address specified
 *
 * Note:            
 *****************************************************************************/
unsigned char readEE(unsigned char addr)  
{
 	EEADR =addr;
	  
  	EECON1bits.EEPGD =0;
  	EECON1bits.CFGS =0;
  	EECON1bits.RD =1;

    return EEDATA;
}


/******************************************************************************
 * Function:        void writeEE(unsigned char address, float data)
 *
 * PreCondition:    None
 *
 * Input:           address, data
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        Writes a float (4 bytes) to EEPROM
 *					Send it the address and the data to place in that address			
 *
 * Note:            MUST HAVE INTERRUPTS TURNED OFF! - do this in HISR
 *					PROBLEM - this might slow everything down (but only takes 32 cycles normally...)
 *****************************************************************************/
void writeEE_float(unsigned char address, float data)
{
	int i;

   	for (i = 0; i < 4; i++) 
      	{
			writeEE(i + address, *(((char*)&data)+i) ) ; 
		}
}

/******************************************************************************
 * Function:        void writeEE(unsigned char address, char data)
 *
 * PreCondition:    None
 *
 * Input:           address, data
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        Writes a char to EEPROM
 *					Send it the address and the data to place in that address			
 *
 * Note:            MUST HAVE INTERRUPTS TURNED OFF! - do this in HISR
 *					PROBLEM - this might slow everything down (but only takes 32 cycles normally...)
 *****************************************************************************/
void writeEE(unsigned char address, char data)
{

	EEADR = address;
	EEDATA = data;
	
	//Configuration as per manual
	EECON1bits.EEPGD =0;
	EECON1bits.CFGS =0;
	EECON1bits.WREN =1; 
	//INTCONbits.GIE = 0;	// Do not need this as it takes place in the HISR
	EECON2 = 0x55;
	EECON2 = 0xAA; 
	EECON1bits.WR = 1;
    while(EECON1bits.WR);      //wait until finished
	//INTCONbits.GIE = 1;	// Do not need this as it takes place in the HISR
	EECON1bits.WREN = 0;
}

/*********************************** EOF user.c *********************************************/
