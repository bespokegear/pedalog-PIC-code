/********************************************************************
 FileName:		main.c
 Dependencies:	See INCLUDES section
 Processor:		PIC18 or PIC24 USB Microcontrollers
 Hardware:		Pedalog Main Program
				This code reads in data from the analogue inputs
				This data is the current and the voltage generated by a device
				See schematic for details (******final schematic******)
				The data is processed to show power and energy.
				There are two switches which control the user interface (via user.c)
				There is an LCD output and an SPI output 
				The device connects via USB using the microchip usb driver (which must be installed)			

 Complier:  	Microchip C18 (for PIC18) or C30 (for PIC24)
 Company:		Microchip Technology, Inc.
				Renewable Energy Innovation

 Software License Agreement:

 The software supplied herewith by Microchip Technology Incorporated
 (the “Company”) for its PIC® Microcontroller is intended and
 supplied to you, the Company’s customer, for use solely and
 exclusively on Microchip PIC Microcontroller products. The
 software is owned by the Company and/or its supplier, and is
 protected under applicable copyright laws. All rights are reserved.
 Any use in violation of the foregoing restrictions may subject the
 user to criminal sanctions under applicable laws, as well as to
 civil liability for the breach of the terms and conditions of this
 license.

 THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.

********************************************************************
 File Description:

 Change History:
  Rev   Date         Description
  1.0   11/19/2004   Initial release
  2.1   02/26/2007   Updated for simplicity and to use common
                     coding style
  3.0	21/05/2009	 Changed for Matts Datalogger initial system
  4.0	24/11/2009	 Sorted out to do correct USB connectivity
  5.0	27/12/2010	 Matt Little - clean up code for pedalog
********************************************************************/

/** INCLUDES *******************************************************/
#include "Compiler.h"
#include "HardwareProfile - Matt Datalogger.h"
#include "GenericTypeDefs.h"
#include "USB/usb_device.h"
#include "USB/usb.h"
#include "USB/usb_function_generic.h"
#include "usb_config.h"
#include "user.h"        

#include <p18cxxx.h>
#include <stdlib.h>
#include <delays.h>
#include <ctype.h>
#include <stdio.h>
#include ".\xlcd.h"
#include <string.h>
#include "max7219matt.h"
#include <spi.h>

/** CONFIGURATION **************************************************/
#if defined(MATT_DAQ)      // Configuration bits for PICDEM FS USB Demo Board (based on PIC18F4550)
        #pragma config PLLDIV   = 5         	// (20 MHz crystal on PICDEM FS USB board) Divide by 5 (20 MHz oscillator input)
        #pragma config CPUDIV   = OSC1_PLL2   	// [OSC1/OSC2 Src: /1][96 MHz PLL Src: /2]
        #pragma config USBDIV   = 2         	// Clock source from 96MHz PLL/2
        #pragma config FOSC     = HSPLL_HS 		//HS oscillator, PLL enabled, HS used by USB
        #pragma config FCMEN    = OFF  			//Fail-Safe Clock Monitor disabled
        #pragma config IESO     = OFF
        #pragma config PWRT     = ON		// Power UP Timer CHANGED
        #pragma config BOR      = ON
        #pragma config BORV     = 3			//  1 means '01' in digital - BOR enabled in software CHANGED FROM 3
        #pragma config VREGEN   = ON      	//USB Voltage Regulator
        #pragma config WDT      = OFF
        #pragma config WDTPS    = 32768
        #pragma config MCLRE    = ON		// MCLR enabled, RE3 disabled as input 
        #pragma config LPT1OSC  = OFF		//Timer1 configured for higher power operation
        #pragma config PBADEN   = OFF
//      #pragma config CCP2MX   = ON
        #pragma config STVREN   = ON
        #pragma config LVP      = OFF
//      #pragma config ICPRT    = OFF       // Dedicated In-Circuit Debug/Programming
        #pragma config XINST    = OFF       // Extended Instruction Set
        #pragma config CP0      = OFF
        #pragma config CP1      = OFF
//      #pragma config CP2      = OFF
//      #pragma config CP3      = OFF
        #pragma config CPB      = OFF
//      #pragma config CPD      = OFF
        #pragma config WRT0     = OFF
        #pragma config WRT1     = OFF
//      #pragma config WRT2     = OFF
//      #pragma config WRT3     = OFF
        #pragma config WRTB     = ON       // Boot Block Write Protection
        #pragma config WRTC     = OFF
//      #pragma config WRTD     = OFF
        #pragma config EBTR0    = OFF
        #pragma config EBTR1    = OFF
//      #pragma config EBTR2    = OFF
//      #pragma config EBTR3    = OFF
        #pragma config EBTRB    = OFF
#else
    #error No hardware board defined, see "HardwareProfile.h" and __FILE__
#endif

/********************** VARIABLES ******************************************************/
//****** These are used for the USB data transmission **********************************/
#pragma udata

extern USB_HANDLE USBGenericOutHandle;
extern USB_HANDLE USBGenericInHandle;
extern DATA_PACKET INPacket;
extern DATA_PACKET OUTPacket;

// This is where the global variables (defined in user.c) are told that they are also in main.c //
// *************ADD THEM ALL HERE IF GOING TO BE USED IN LOADS OF PLACES************************//

#pragma udata

extern char VoltStr;				// The voltage string to send via USB XX.X
extern char I_out_Str;				// The current string to send vis USB XX.X
extern char P_O_Str;				// The power string to send via USB
extern char P_Ave_Str;				// The power string to send via USB
extern char P_Max_Str;				// The power string to send via USB
extern char E_O_Str;				// The Energy string to send back via USB
extern char E_O_Str_disp;			// The Energy string to send back via USB
extern char total_run_time_s_str; 	// The total run time string to send back via USB
extern char temp_run_time_s_str; 	// The temp run time string to send back via USB
extern char Money_Str;				// The power string to send via USB

extern float V_conversion;			// This comes from the initialisation routine in User.c
extern float P_conversion;			// This comes from the initialisation routine in User.c
extern float E_conversion;			// This comes from the initialisation routine in User.c
extern float I_conversion;			// This comes from the initialisation routine in User.c
extern float M_conversion;			// This comes from the initialisation routine in User.c
extern unsigned int T_conversion;	// This comes from the initialisation routine in User.c
extern const rom int sample_freq;	// This comes from the set-up in User.c
extern double M_conv;				// This is the money conversion value
extern BOOL adjustment_flag;		// This says if the display should show the adjustment mode

extern int display_mode;			// This is a value to decide which value to show on the LCD display (from user.c)
extern int update_display;			// This is a flag to say when the display should be updated
extern int LCD_ramp_up;				// This is a flag to say when the LCD backlight should be switched ON
extern int voltage_applied;			// This is to show when applied voltage is >5V then keep backlight ON
extern int buzzer_flag;				// This flag sets off the buzzer for 0.2seconds
extern const rom int max_count_HISR;// This is the averaging period in terms of numbers of samples - sent from user.c. 
extern char reset_temp_flag;		// This is a flag to reset the temp values (in the LISR)

extern int SPIdisplayflag;		// This flag sets which value will be displayed on the SPI bus

// **********************END OF EXTERNAL VARIABLES*********************************//


// ****************************** LOCAL VARIABLES *********************************//
// ***************** Variables required for HISR **********************************//
int counter_HISR = 0;			      	// This is a high priority interrupt routine timer for averaging values
int timerstore=0;				// This stores the timer0 value to ensure that it is always accurate
char average_data_flag=FALSE;	// when this is true it will tell the code to display the stored data
int	counterHISR=0;				// Counter for the LED indicating the main HISR routine
BOOL hold_values=TRUE;				// This is a flag to say when to update the values

// ***************** Variables required for LISR **********************************//
int	counterLISR=0;		// Counter for the LED indicating the LISR routine
int buzzer_timer=0;			// A timer for the buzzer noise

char cost_conv_st[6]={'\0'};

//*****************Voltage variables**************
unsigned int V_raw=0;					// Raw data from ADC AN2
unsigned long int V_ave_sum=0;			// Summation of raw data
unsigned long int V_ave_raw=0;			// Summation of raw data for passing to LISR routine
float V_act=0;							// The actual processed voltage
char* V_str; 							// This is the pointer to the Voltage string to display

//*****************Current OUT variables******************
int I_out_raw=0;				// Raw data from ADC AN1
unsigned long int I_out_ave_sum=0;		// Summation of raw data
unsigned long int I_out_ave_raw=0;		// Average of raw data
float I_out_act=0;						// The actual processed current
char *I_out_str;						// This is the pointer to the Current string to display

//*****************Spare DAQ variables*********************
unsigned int Spare_raw=0;			// Raw data from ADC AN3

//*****************Power and Energy Variables***************
float W_out_ave_sum=0;
float W_out_ave_raw=0;
float Power_out=0;
char *P_out_str;

float Power_max=0;
char *P_max_str;

float Power_ave=0;
char *P_ave_str;

float Energy_out_Wh=0;
float Energy_out_display=0;
int	E_out_disp_unit=0;
char *E_out_str;

float Energy_temp=0;

float Money_display=0;
char *M_str;

//*****************Run Time Variables***************
char *run_time_s_str;	// This the staring variable for the total_run_time
unsigned long int temp_run_time_s=0;	// This stores the temp run time in seconds
float temp_run_time_double=0;			// This stores the temp run time as a float (i.e. with fractions of seconds)
char *temp_time_s_str;				// This the staring variable for the temp_run_time

//****************LCD DISPLAY VARIABLES***********************************
int addr;					// a general purpose address holder
int	n=0;					// A general purpose counter
int	LCDbacklight_counter=0;	// This is a counter for the LCD backlight routine
int	LCDbacklight_timer=0;	// This is a timer for the LCD backlight routine to change 
int	LCDbacklight_value=20;  // This is the maximum number of steps for the LCD backlight ramp up

int LCD_step_counter=0;		// Timer for the ramp up/down LCD backlight
int LCD_cycle_counter=0;	// Timer for the ramp up/down LCD backlight
int LCD_increment_max=20;	// This is the number of steps through which the ramp up/down goes.
int LCD_gen_counter=0;		// This is a general counter for doing this routine

int TEST_COUNT=0;		// TEST counter for the SPI

const rom char 	P_text[7]={'P','O','W','E','R',':','\0'};
const rom char 	P_max_text[7]={'P',' ','M','A','X',':','\0'};
const rom char 	P_ave_text[7]={'P',' ','A','V','E',':','\0'};
const rom char 	P_unit[2]={'W','\0'};

const rom char 	E_text[8]={'E','N','E','R','G','Y',':','\0'};
const rom char	E_Wh_unit[3]={'W','h','\0'};
const rom char	E_kWh_unit[4]={'k','W','h','\0'};

const rom char 	V_text[7]={'V','O','L','T','S',':','\0'};
const rom char	V_unit[2]={'V','\0'};

const rom char 	I_text[6]={'A','M','P','S',':','\0'};
const rom char 	I_unit[2]={'A','\0'};

const rom char 	Time_text[6]={'T','I','M','E',':','\0'};
const rom char	Time_unit_s[2]={'s','\0'};
const rom char	Time_unit_m[2]={'m','\0'};
const rom char	Time_unit_h[2]={'h','\0'};

const rom char 	M_text[7]={'M','O','N','E','Y',':','\0'};
const rom char	M_unit[2]={'p','\0'};

const rom char 	Error_text[10]={'*','*','E','R','R','O','R','*','*','\0'};
const rom char 	M_conv_text[8]={'$',' ','C','O','N','V',':','\0'};
const rom char 	Adjust_text[17]={' ',' ','A','D','J','U','S','T',' ','M','O','D','E',' ',' ',' ','\0'};

//******Variables for int to string conversion:************
char *presult;			// A pointer to the result from the conversion routine
char string[10];		// Holder for the int to string conversion
char result[10]; 		// Holder for the result from the int to string conversion (temp storage)
char result2[10]; 		// Holder for the result from the int to string conversion (temp storage)

int	lengthres=0;		// This is a temp store for the length of a result used in conversion subroutine

const rom char zero[2]={'0'};			// These are strings to get the display correct
const rom char decimalpt[2]={'.'};		// These are strings to get the display correct
const rom char null[2]={'\0'};			// These are strings to get the display correct
const rom char nulls[9]={'\0','\0','\0','\0','\0','\0','\0','\0'};			// These are strings to get the display correct

/***************Write to EEPROM variables*********************************/
//int write_eeprom_cntr=0;	// This is a counter to time when to write the next eeprom value

/*****************SPI Variables******************************************/
unsigned char val;						// This is temp variable for the SPI routines
const rom char zeroSPI[2]={'0','0'};	// This is for the SPI display 

/** PRIVATE PROTOTYPES *********************************************/
static void InitializeSystem(void);
void USBDeviceTasks(void);
void USBDeviceAttach(void);				// ****CHANGED*****
void YourHighPriorityISRCode(void);
void YourLowPriorityISRCode(void);
char* ConvertIntStr(long int intstr, int digits);
char* ConvertkWhtodisplay(long int Wh_value);
char* ConvertSecondStr(unsigned long int intstr);
void cursor_1_space(void);
void cursor_0_space(void);
void LCD_blank_end(void);
char* ConvertTimeStr(unsigned long int intstr);
void MAX7219WriteValueDP(unsigned int value, int dp);
void MAX7219Write(unsigned char reg_address, unsigned char dataout);
void MAX7219WriteStringDP(char string[5], int dp);

/** VECTOR REMAPPING ***********************************************/
#if defined(__18CXX)
	//On PIC18 devices, addresses 0x00, 0x08, and 0x18 are used for
	//the reset, high priority interrupt, and low priority interrupt
	//vectors.  However, the current Microchip USB bootloader 
	//examples are intended to occupy addresses 0x00-0x7FF or
	//0x00-0xFFF depending on which bootloader is used.  Therefore,
	//the bootloader code remaps these vectors to new locations
	//as indicated below.  This remapping is only necessary if you
	//wish to program the hex file generated from this project with
	//the USB bootloader.  If no bootloader is used, edit the
	//usb_config.h file and comment out the following defines:
	//#define PROGRAMMABLE_WITH_USB_HID_BOOTLOADER
	//#define PROGRAMMABLE_WITH_USB_LEGACY_CUSTOM_CLASS_BOOTLOADER
	
	#if defined(PROGRAMMABLE_WITH_USB_HID_BOOTLOADER)
		#define REMAPPED_RESET_VECTOR_ADDRESS			0x1000
		#define REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS	0x1008
		#define REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS	0x1018
	#elif defined(PROGRAMMABLE_WITH_USB_MCHPUSB_BOOTLOADER)	
		#define REMAPPED_RESET_VECTOR_ADDRESS			0x800
		#define REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS	0x808
		#define REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS	0x818
	#else	
		#define REMAPPED_RESET_VECTOR_ADDRESS			0x00
		#define REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS	0x08
		#define REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS	0x18
	#endif
	
	#if defined(PROGRAMMABLE_WITH_USB_HID_BOOTLOADER)||defined(PROGRAMMABLE_WITH_USB_MCHPUSB_BOOTLOADER)
	extern void _startup (void);        // See c018i.c in your C18 compiler dir
	#pragma code REMAPPED_RESET_VECTOR = REMAPPED_RESET_VECTOR_ADDRESS
	void _reset (void)
	{
	    _asm goto _startup _endasm
	}
	#endif
	#pragma code REMAPPED_HIGH_INTERRUPT_VECTOR = REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS
	void Remapped_High_ISR (void)
	{
	     _asm goto YourHighPriorityISRCode _endasm
	}
	#pragma code REMAPPED_LOW_INTERRUPT_VECTOR = REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS
	void Remapped_Low_ISR (void)
	{
	     _asm goto YourLowPriorityISRCode _endasm
	}
	
	#if defined(PROGRAMMABLE_WITH_USB_HID_BOOTLOADER)||defined(PROGRAMMABLE_WITH_USB_MCHPUSB_BOOTLOADER)
	//Note: If this project is built while one of the bootloaders has
	//been defined, but then the output hex file is not programmed with
	//the bootloader, addresses 0x08 and 0x18 would end up programmed with 0xFFFF.
	//As a result, if an actual interrupt was enabled and occured, the PC would jump
	//to 0x08 (or 0x18) and would begin executing "0xFFFF" (unprogrammed space).  This
	//executes as nop instructions, but the PC would eventually reach the REMAPPED_RESET_VECTOR_ADDRESS
	//(0x1000 or 0x800, depending upon bootloader), and would execute the "goto _startup".  This
	//would effective reset the application.
	
	//To fix this situation, we should always deliberately place a 
	//"goto REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS" at address 0x08, and a
	//"goto REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS" at address 0x18.  When the output
	//hex file of this project is programmed with the bootloader, these sections do not
	//get bootloaded (as they overlap the bootloader space).  If the output hex file is not
	//programmed using the bootloader, then the below goto instructions do get programmed,
	//and the hex file still works like normal.  The below section is only required to fix this
	//scenario.

	#pragma code HIGH_INTERRUPT_VECTOR = 0x08
	void High_ISR (void)
	{
	     _asm goto REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS _endasm
	}
	#pragma code LOW_INTERRUPT_VECTOR = 0x18
	void Low_ISR (void)
	{
	     _asm goto REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS _endasm
	}
	#endif	//end of "#if defined(PROGRAMMABLE_WITH_USB_HID_BOOTLOADER)||defined(PROGRAMMABLE_WITH_USB_LEGACY_CUSTOM_CLASS_BOOTLOADER)"

	#pragma code
	
	
	//These are your actual interrupt handling routines.
	#pragma interrupt YourHighPriorityISRCode
	void YourHighPriorityISRCode()
	{
		//****************** START OF THE HIGH PRIORITY INTERRUPT ROUTINE ****************//
		// ********************HISR is controlled by TIMER0 overflow *********************//

		if(INTCONbits.TMR0IF = 1)		// Do this section if there has been a TMR0 Overflow
		{
			//***********Bodge to sort out timer0 problems***************************//
			timerstore=TMR0L;		// Store the timer low value
			if(timerstore==0x20){	// This is a bodge as sometimes the TMR0L comes in on 03 and sometimes
				Nop();				// it is 02. Hence must delay slightly if it is 02 to ensure same delay
				Nop();			
			}

			// ******* COMMENT OUT THE SMPLE FREQUENCY NOT REQUIRED ********************//

			//**********TIMER0 values are H=0xF7, L=0x7E for 5000Hz samples*************//
			//TMR0H = 0xF7; // Load TIMER0 with a value - makes delay shorter - (5000Hz samples) 0.2mS with these values (48MHz/4 clock)
			//TMR0L = 0x7E; // Load TIMER0 with a value - makes delay shorter 
			//************************************************************************//

			//**********TIMER0 values are H=0xE9, L=0x6E for 2000Hz samples*************//
			TMR0H = 0xE9; // Load TIMER0 with a value - makes delay shorter 
			TMR0L = 0xC2; // Load TIMER0 with a value - makes delay shorter 
			//************************************************************************//

			// Read in Voltage on AN0 and Current Out on AN1. AN2 and AN3 can be read but are spare

			//	This reads the voltage
			mInitAN0();
	        ADCON0bits.GO = 1;              // Start AD conversion for channel AN0 
	        while(ADCON0bits.NOT_DONE);     // Wait for conversion - do nothing until conversion complete
			{}
			V_raw =  ADRESL + (ADRESH*255);	// The raw voltage is a value 0-1024, which is 10 bits. Hence real value comes from the two 8bit numbers

			//	This is for the OUT current
			mInitAN1();						// Start AD conversion for channel AN1 (Current OUT)
	        ADCON0bits.GO = 1;              // Start AD conversion
	        while(ADCON0bits.NOT_DONE);     // Wait for conversion
			{}
			I_out_raw = ADRESL + (ADRESH*255);	// Gives the 10bit raw value

			// ********Want to do basic processing of the data here************************************

			// Calulate V, I, W - will do other processing in the LISR
			// To keep accuracy the samples are added into large variables and only averaged in the 'if' loop

			I_out_ave_sum = I_out_ave_sum + (long int)I_out_raw;					// Add on the next I out sample	
			V_ave_sum = V_ave_sum + (long int)V_raw;								// Add on the next V sample
			W_out_ave_sum = W_out_ave_sum + ((long int)I_out_raw*(long int)V_raw);	// Add on the power out measurement

			counter_HISR++;					// Increment the HISR counter
	
			// ********This is to process the averages when we get to the sample period******************
			if(counter_HISR>=max_count_HISR)	// Goes into this loop every h_isr_count 
												// Perform an average every time this event occurs 
			{	
				V_ave_raw = V_ave_sum;			// Store the data so that the LISR can take care of it slowly.
				I_out_ave_raw = I_out_ave_sum;
				W_out_ave_raw = (float)W_out_ave_sum;

				V_ave_sum = 0;		// Reset all the sums
				I_out_ave_sum = 0;
				W_out_ave_sum = 0;

				average_data_flag=TRUE;		// Set average flag to average the data
				counter_HISR=0;	// Reset the counter to wait another for 'max_count_HISR' milliseconds
			}

			//***********Here we do a PWM for the LED backlight to make it look nice**************
			//**** This routine performs a psudo-PWM rampm up and ramp down for the backlight ****
			// The HISR frequecy is used to control the on/off flashing of the display
			// The backlight will ramp up in increments of 100 cycles (chosen here). 
			// It will go through LCD_increment_max to reach full brightness
			// Whether the LCD backlight is used is decided in the user.c routine relating to the switches
		
			if(LCD_cycle_counter>=100)
			{
				if(LCD_ramp_up==TRUE)
				{
					LCD_step_counter++;	// Increment the step counter
				} 
				else if(LCD_ramp_up==FALSE)
				{
					LCD_step_counter--;	// decrement the step counter
				}

				if (LCD_step_counter>=LCD_increment_max)	// This is the number of increments to go through	
				{
					LCD_step_counter=LCD_increment_max;
				}
				else if (LCD_step_counter<=0)	
				{
					LCD_step_counter=0;
				}

				LCD_cycle_counter=0; 	// Reset the cycles counter
			}
			LCD_cycle_counter++;		// inc the cycles counter

			if(LCD_gen_counter>=LCD_step_counter)
			{
				mLCD_backled_Off();
			}
			else				
			{
				mLCD_backled_On();
			}
	
			LCD_gen_counter++;

			if(LCD_gen_counter>=LCD_increment_max)
			{
				LCD_gen_counter=0;
			}					

						 
			//************************************End of LCD PWM*******************************************

			//***********************BUZZER************************************************
			//******** This beeps if the buzzer_flag is set high **************************
			if(buzzer_flag==TRUE)
			{	
				buzzer_timer++;
				mBUZZ_Toggle();
				if(buzzer_timer>=200)
				{
					buzzer_flag=FALSE;
					buzzer_timer=0;
				}
			}
			else
			{
				mBUZZ_Off();
			}
			//***************END of BUZZER routine*****************************************


			// ***************************************************************************
		}	//*** end of TIMER0 overflow if statement**********************************//

		#if defined(USB_INTERRUPT)
		// ************** SERVICE USB ENSURE COMMS IS MAINTAINED***********************//
		// Here the USB is checked to ensure communication is maintained if plugged in
		// This is a mix of polling and interrupt
		// Using interrupt set-up (by calling USBDeviceAttach() in the initialisation)
		// The HISR is initialised seperately 
		// USBdeviceTasks() must be called every 100uS when attached, that is done here.
		// Check bus status and service USB interrupts.
        USBDeviceTasks(); // Interrupt or polling method.  If using polling, must call
        				  // this function periodically.  This function will take care
        				  // of processing and responding to SETUP transactions 
        				  // (such as during the enumeration process when you first
        				  // plug in).  USB hosts require that USB devices should accept
        				  // and process SETUP packets in a timely fashion.  Therefore,
        				  // when using polling, this function should be called 
        				  // frequently (such as once about every 100 microseconds) at any
        				  // time that a SETUP packet might reasonably be expected to
        				  // be sent by the host to your device.  In most cases, the
        				  // USBDeviceTasks() function does not take very long to
        				  // execute (~50 instruction cycles) before it returns.
		//*******************END OF USB COMMS*******************************************//
        #endif

		//***********These values reset all counters and interrupt flags etc********//
		INTCONbits.TMR0IF = 0;	// Interrupt control register: Reset Tmr0 overflow flag
		//**************** END OF THE HIGH PRIORITY INTERRUPT ROUTINE *************//

	}	//This return will be a "retfie fast", since this is in a #pragma interrupt section 

	#pragma interruptlow YourLowPriorityISRCode
	void YourLowPriorityISRCode()
	{
		//**************** START OF THE LOW PRIORITY INTERRUPT ROUTINE *************//
		//***************This uses TIMER2 with a 16 x PRESCALER*********************//
		//****** TMR2 is an 8-bit counter. Interrupt generated when this rolls over*//
		//*** With prescaler=16 then instruction cycles = 16x256 = 4096*************//
		//*** Clock =48MHz, Intsrutctions = 48MHz/4=12MHz. This runs around 3kHz****//


		//****************SHOW POWER IS APPLIED*******************************************
		//**********This counter flashes the LED2 on/off for 0.1s every 0.3s ***********//

		if(hold_values==TRUE)	// Only want to flash the LED if the numbers are being held.
		{	
			counterLISR++;			
			if (counterLISR>=0&&counterLISR<=200)
			{
				mLED_OUT_2_On();	// To indicate Power	
			}
			else if(counterLISR>=4000)
			{
				counterLISR=0;
			}
			else
			{
				mLED_OUT_2_Off();	// To indicate Power
			}
		}
		else
		{
			mLED_OUT_2_On();
			counterLISR=0;
		}
		//************************End of LED2 control routine***********************//	


		if(average_data_flag==TRUE)		// This section of code only runs when the H ISR had got new data (average_data_flag is set)
										// Otherwise we jump out of the low priority ISR
		{
			// In the LISR jobs to do are:
			// Process the data (conevert to real-world value)
			// Display the data on the LCD screen (depends upon state machine for display from main loop)
			// Ensure the data is available for the USB pipe (if asked for) 
			
			//*********************Average Data******************************************
			// Data has arrived from the HISR as a large summation of all the samples
			// Processing requires a divide command which is very slow (725 instructions each)
			// This cannot be done in the HISR as more samples must be taken, 
			// hence it is done more slowly in the LISR.
			// Each division routine takes 725 instruction cycles
			// Hence this part of the prog uses a minimum of 725 x 5 = 3625 cycles. Must be done in LISR
			// Try to limit the number of divisions, hence push together averaging and processing.

			// ***************************VOLTAGE*************************************************
			// The voltage comes from a potential divider
			// Values are 560k and 100k which is then buffered with an op-amp to provide current to the AD
			// High precision resistors must be used
			// Hence the voltage is	Vin (100/(560+100)) = Vread, which is a value 0-1024 relating to 0-5V
			// Hence caluclate the voltage from V_ave_raw x (5/1024) x ((560+100)/100)
			// This can also be calculated from knowing the actual voltage when the ADC voltage is 5V
			// With 560k and 100k: 5v x ((560+100)/100) = 33, Hence Vmax = 33V
			// 
			// What we want to do to get the correct voltage value:
			// V_ave_sum/max_count_HISR = V_ave_raw
			// V_act = V_ave_raw * (5/1024) * ((R1+R2)/R2)
			// This involves a lot of divisions, so push multiplications together then do one main division
			//
			// This reduces to V_act = (V_ave_sum*5*(R1+R2))/(max_count_HISR*1024*R2)
			// The values of R1 and R2 MUST BE WRITTEN IN 10's OF KOHMS
			// This allows the maximum number of samples before an average to be 15887 (7s at 2kHz, 3s at 5kHz)

			// Lots of methods to do this.
			// The following uses a pre-calculated conversion factor (from mInitConversion)
			// It takes approx 546 cycles
			// The value of 100 increases the resolution so that the value can be converted correctly

			V_act = (float)V_ave_raw*V_conversion;	// Average out the values (every max_count_HISR samples) (546 cycles)

			if(V_act>=800)	// This keeps on the LCD backlight if there is external voltage applied.
							// The value (800) is the voltage multiplied by 100 (8V x 100 = 800 in this case) 
			{
				voltage_applied=TRUE;
			}
			else
			{
				voltage_applied=FALSE;
			}
			
			// ***************************CURRENT OUT*************************************************
			// Current is measured using a INA168 current monitor and a shunt resistor (shunt resistor value is entered in user.c)
			// The resistor can be changed to give different current ratings for the monitor
			// The value of 100  (in the conversion) increases the resolution so that the value can be converted correctly

			I_out_act = ((float)I_out_ave_raw*I_conversion) ;		// Convert the raw data into the actual current value. (546 cycles)
																		
			// ***************************Power OUT*************************************************
			// Must convert the power value correctly into its real value. 
			// This is DC power so power factor is not an issue
			// Should do the V*I multiplication in the H_ISR loop then use the average to convert.
			// Data comes from the HISR as an instantaneous multiple of V x I
			// Max actual power is around 2000W
			// Use the V conversion and I conversion values to get the actual value. 
			
			Power_out = W_out_ave_raw*P_conversion;  
			

			// ***************************Power MAX*************************************************
			// This displays the maximum power generated by the user
			if(Power_out>Power_max)
			{
				Power_max = Power_out;
			}

			

			if(hold_values==FALSE)	// only do this when we are not holding the values
			{

				// ***************************Energy OUT and TEMP energy *************************************************
				// ****Here the value of power is integrated to give an energy value***
				// Cumulative Energy = Sum of (power x sample period)
				// Data is read at 2000Hz hence why each value is for (max_count_HISR/2000)s = 0.5s
				// Convert Ws into Wh to give actual energy. 
				// Ws to Wh means divide by 3600 (60x60) 
				// but power also has a factor of 100 included so must also cancel this (hence 360000).
				// The energy conversion value is calculated in the initialisation routine to reduce the number of divide commands used
				Energy_out_Wh =  Energy_out_Wh + (Power_out*E_conversion);  	// This line cals the total energy OUT
	
				// ***************************Money generated*************************************************
				// This displays the average money generated by the user (energy multiplied by the cost)
				Money_display = (float)Energy_out_Wh*M_conversion;
	
				// ***************************Total and Temp RUN time**************************************
				// The things which relate to this section of cade are the temp_run_time_s and the power_average
				// Here we sort out the total RUN time - this can be reset with a full reset******
				// The sample rate is 2000Hz. This routine is entered every max_count_HISR
				// Therefore each time entered here add on max_count_HISR/sample_freq
					
				// Problems are that the temp_run_time_s is an intger and does not like half-seconds etc.
				// Only want to add on to the temp_run_time_s when a whole number is generated
	
				temp_run_time_double = temp_run_time_double + (max_count_HISR/sample_freq);
				temp_run_time_s = temp_run_time_double;		// Increment the temp run time integer as well
															// This conversion works by ignoring any fractions
	
				// ***************************Power AVE*************************************************
				// This displays the average power generated by the user (energy divided by time)
				// Only do this when the timer has been sorted out or you get a crazy value (divide by 0)
				// Calculate the power from the total energy generated x 60 x 60 (convert Wh to W) and add in a 100 factor.
				// 60 x 60 x 100 = 360000
				// Divide through by the total run time to give the average power over that time period
				//******************TEST THIS!!!!!!!!!!!!!!! 15/9/10 *********************************//
				
				Power_ave = ((float)Energy_out_Wh*360000)/(float)temp_run_time_double;
			}
	

			//***************RESET any temp variables***********************************************
			//*****RESET temp variables if the reset_temp_flag has been set from user.c file********
			
			if(reset_temp_flag==1)
			{
				//********This is the RESET rountine
				//****Enter here if the temp variables are to be reset****//
				temp_run_time_double=0;
				temp_run_time_s=0;
				Power_ave=0;
				Power_max=0;				
				Energy_out_Wh=0;
				Money_display=0;

				hold_values=FALSE;
				//*****Want to reset the display values***********************
				reset_temp_flag=2; 	// Set the reset flag to do nothing (no case)
			}
			else if(reset_temp_flag==3)
			{
				//********This is the HOLD VALUES routine
				hold_values=TRUE;
				reset_temp_flag=0; 	// Set the reset flag to do nothing (no case)
			}

			//************************ STORE THE DATA **********************************************
			// Here the information is stored into the relevant variables so it can be used when required
			
			// The voltage, current and power are all to always be displayed (NEVER held)

			memset(&VoltStr,'\0',5);					// This line clears the string to get rid of anything left in there...
			V_str = ConvertIntStr(V_act,1);			// Call the subroutine to convert the int value into a display value (3133 cycles)
			strcpy(&VoltStr,V_str);					// This copies the data pointed to by V_str into the array VoltStr (68 cycles)

			memset(&I_out_Str,'\0',6);					// This line clears the string to get rid of anything left in there...
			I_out_str = ConvertIntStr(I_out_act,2);	// Call the subroutine to convert the int value into a display value (3133 cycles)
			strcpy(&I_out_Str,I_out_str);			// This copies the data pointed to by V_str into the array VoltStr (68 cycles)

			memset(&P_O_Str,'\0',6);					// This line clears the string to get rid of anything left in there...
			P_out_str = ConvertIntStr(Power_out,1);	// Call the subroutine to convert the int value into a display value (3133 cycles)
			strcpy(&P_O_Str,P_out_str);				// This copies the data pointed to by V_str into the array VoltStr (68 cycles)

			// ****Here want to ensure that the rest of the data in the strings is deleted?****

			// The other parameters are held if the mode says they should be (cyclist test stopped)
			if (hold_values==FALSE)	
			{

				memset(&P_Max_Str,'\0',6);					// This line clears the string to get rid of anything left in there...
				P_max_str = ConvertIntStr(Power_max,1);		// Call the subroutine to convert the int value into a display value (3133 cycles)
				strcpy(&P_Max_Str,P_max_str);				// This copies the data pointed to by V_str into the array VoltStr (68 cycles)

				memset(&P_Ave_Str,'\0',6);					// This line clears the string to get rid of anything left in there...	
				P_ave_str = ConvertIntStr(Power_ave,1);		// Call the subroutine to convert the int value into a display value (3133 cycles)
				strcpy(&P_Ave_Str,P_ave_str);				// This copies the data pointed to by V_str into the array VoltStr (68 cycles)

				memset(&E_O_Str,'\0',8);					// This line clears the string to get rid of anything left in there...
				E_out_str=ConvertIntStr(Energy_out_Wh,2);
				strcpy(&E_O_Str,E_out_str);
			
				// If the Wh get too large (max value is 999999Wh) then convert to kWh generated						
				if(Energy_out_Wh>=100000)
				{
					// This is for the high range 100.0kWh to 9999.9kWh
					Energy_out_display=(Energy_out_Wh)/10;				
					E_out_disp_unit=1;	// Show 'kWh'
					E_out_str=ConvertIntStr(Energy_out_display,1);
				}			
				else if(Energy_out_Wh>=1000)
				{
					// This is for the medium range 1.00kWh to 99.99kWh
					Energy_out_display=Energy_out_Wh/10;	
					E_out_disp_unit=1;	// Show 'kWh'
					E_out_str=ConvertIntStr(Energy_out_display,2);
				}
				else
				{
					// this is for the low range 0.00 to 999.99Wh
					Energy_out_display=Energy_out_Wh*100;
					E_out_disp_unit=0; 	// Show 'Wh'
					E_out_str=ConvertIntStr(Energy_out_display,2);
				}
				strcpy(&E_O_Str_disp,E_out_str);// This line saves the energy value to display, rather than the pointer which is messed up by calling the subroutine again

				temp_time_s_str = ConvertSecondStr(temp_run_time_s);		// Put the total run time into a display value		
				strcpy(&temp_run_time_s_str, temp_time_s_str);  // This is for the display on the LCD (THIS WORKS WELL)


				// Want to send the actual seconds value via the USB
				memset(&total_run_time_s_str,'\0',9);					// This line clears the string to get rid of anything left in there...
				run_time_s_str = ConvertTimeStr(temp_run_time_s);		// Put the total run time into a display value
				strcpy(&total_run_time_s_str, run_time_s_str);			// Send the total seconds value back via USB.

				memset(&Money_Str,'\0',8);					// This line clears the string to get rid of anything left in there...
				M_str=ConvertIntStr(Money_display,2);
				strcpy(&Money_Str,M_str);	

			}

			average_data_flag=FALSE;	// Reset the average data flag for the next set of samples.
			update_display=TRUE;		// Sets the update display flag
		}

		
		if(update_display==TRUE)
		{

			//************************ DISPLAY THE DATA **********************************************
			// Here the information is displayed on the LCD, depending upon the display state required
			// Want to display the voltage and power on the bottom row
			// The top row will display what ever the display_mode variable indicates
			// Ensure that the max_display_mode covers all the cases available

			// The disply shows POWER:  on line 1 and ENERGY: on line 2 
			// The top line can be scrolled through and so has the 'case' code.
			// Unless we are in adjustment mode in which case this bottim line will just show 'ADJUSTMENT'
			// First we show the energy generated on the bottom row:	

			SetDDRamAddr(0x40);				// Put the cursor in the correct position (1983 cycles)
			while(BusyXLCD());				// (1964 cycles with no LCD connected)
			if(adjustment_flag==FALSE)
			{
				putrsXLCD(E_text);			// Puts the 'Power:' onto the screen
				while(BusyXLCD());
				lengthres=strlen(&E_O_Str_disp);					
				for	(n=0;n<(7-lengthres);n++)			// Blank the section from the end of V up to I
				{
					putcXLCD(' ');					// Blank out any unused bits 
					while(BusyXLCD());	
				}
				putsXLCD(&E_O_Str_disp);			// Puts the value onto the screen
				while( BusyXLCD() );						
				if(E_out_disp_unit==0)
				{
					putrsXLCD(E_Wh_unit);			// Puts the unit after the value
				}
				else
				{
					putrsXLCD(E_kWh_unit);			// Puts the unit after the value
				}
				while(BusyXLCD());
				putcXLCD(' ');					// Blank out any unused bits 
				while(BusyXLCD());
			}
			else
			{
				putrsXLCD(Adjust_text);			// Puts the '  ADJUST MODE   ' onto the screen
				while(BusyXLCD());
			}

	

			//*******************DISPLAY DEPENDING UPON THE MODE*************************************

			switch(display_mode)
			{
				case 1:		// In this case show the Power from the generator
					
					cursor_0_space();		
					putrsXLCD(M_text);			// Puts the 'Power:' onto the screen
					while(BusyXLCD());
					lengthres=strlen(&Money_Str);					
					for	(n=0;n<(8-lengthres);n++)			// Blank the section from the end of V up to I
					{
						putcXLCD(' ');					// Blank out any unused bits 
						while(BusyXLCD());	
					}
					putsXLCD(&Money_Str);			// Puts the value onto the screen
					while( BusyXLCD() );						
					putrsXLCD(M_unit);			// Puts the unit after the value
					while(BusyXLCD());
					LCD_blank_end();				
					break;

				case 2:		// In this case show the Power from the generator
					
					cursor_0_space();		
					putrsXLCD(P_text);			// Puts the 'Power:' onto the screen
					while(BusyXLCD());
					lengthres=strlen(&P_O_Str);					
					for	(n=0;n<(8-lengthres);n++)			// Blank the section from the end of V up to I
					{
						putcXLCD(' ');					// Blank out any unused bits 
						while(BusyXLCD());	
					}
					putsXLCD(&P_O_Str);			// Puts the value onto the screen
					while( BusyXLCD() );						
					putrsXLCD(P_unit);			// Puts the unit after the value
					while(BusyXLCD());
					LCD_blank_end();				
					break;

				case 3:		// In this case show the total time since the 'new cyclist' button pressed


					cursor_1_space();
					putrsXLCD(Time_text);			// Puts 'TIME:' onto the screen
					while(BusyXLCD());
					lengthres=strlen(&temp_run_time_s_str);					
					for	(n=0;n<(10-lengthres);n++)			// Blank the section from the end of V up to I
					{
						putcXLCD(' ');					// Blank out any unused bits 
						while(BusyXLCD());	
					}
					putsXLCD(&temp_run_time_s_str);			// Puts the value onto the screen
					while( BusyXLCD() );
					LCD_blank_end();
					break;

				case 4:			// In this case show the maximum power that the rider generated

					cursor_0_space();		
					putrsXLCD(P_max_text);			// Puts the 'Power:' onto the screen
					while(BusyXLCD());
					lengthres=strlen(&P_Max_Str);					
					for	(n=0;n<(8-lengthres);n++)			// Blank the section from the end of V up to I
					{
						putcXLCD(' ');					// Blank out any unused bits 
						while(BusyXLCD());	
					}
					putsXLCD(&P_Max_Str);			// Puts the value onto the screen
					while( BusyXLCD() );						
					putrsXLCD(P_unit);			// Puts the unit after the value
					while(BusyXLCD());
					LCD_blank_end();
					break;

				case 5:		// In this case show the Average Power over the time since new cyclist button pressed

					cursor_0_space();		
					putrsXLCD(P_ave_text);			// Puts the 'Power:' onto the screen
					while(BusyXLCD());
					lengthres=strlen(&P_Ave_Str);					
					for	(n=0;n<(8-lengthres);n++)			// Blank the section from the end of V up to I
					{
						putcXLCD(' ');					// Blank out any unused bits 
						while(BusyXLCD());	
					}
					putsXLCD(&P_Ave_Str);			// Puts the value onto the screen
					while( BusyXLCD() );						
					putrsXLCD(P_unit);			// Puts the unit after the value
					while(BusyXLCD());
					LCD_blank_end();
					break;

				case 6:		// In this case show the Voltage

					cursor_0_space();	
					putrsXLCD(V_text);			// Puts the 'Energy:' onto the screen
					while(BusyXLCD());
					lengthres=strlen(&VoltStr);					
					for	(n=0;n<(8-lengthres);n++)			// Blank the section from the end of V up to I
					{
						putcXLCD(' ');					// Blank out any unused bits 
						while(BusyXLCD());	
					}
					putsXLCD(&VoltStr);			// Puts the value onto the screen
					while( BusyXLCD() );
					putrsXLCD(V_unit);			// Puts the unit after the value
					while(BusyXLCD());				
					LCD_blank_end();

					break;

				case 7:		// In this case show the Current

					cursor_1_space();
					putrsXLCD(I_text);				// Puts the 'Current:' onto the screen
					while(BusyXLCD());
					lengthres=strlen(&I_out_Str);					
					for	(n=0;n<(8-lengthres);n++)			// Blank the section from the end of V up to I
					{
						putcXLCD(' ');					// Blank out any unused bits 
						while(BusyXLCD());	
					}
					putsXLCD(&I_out_Str);				// Puts the value onto the screen
					while( BusyXLCD() );
					putrsXLCD(I_unit);				// Puts the unit after the value
					while(BusyXLCD());				
					LCD_blank_end();			
					break;	

				case 8:		// In this case show the conversion value (M_conv)

					// First convert the float number into a string....
					// sprintf does not work with floats in MPLAB MCC C18, hence sprintf does not work normally
					// To make it work got to multiply by 1000 and add in the decimal place....
					sprintf(cost_conv_st,"%d.%01u", (int)M_conv, ((int) (((M_conv)-(int)M_conv) * 10)) );
			
					cursor_0_space();
					putrsXLCD(M_conv_text);				// Puts the '$ conv:' onto the screen
					while(BusyXLCD());
					lengthres=strlen(cost_conv_st);					
					for	(n=0;n<(7-lengthres);n++)			// Blank the section from the end of V up to I
					{
						putcXLCD(' ');					// Blank out any unused bits 
						while(BusyXLCD());	
					}
					putsXLCD(cost_conv_st);				// Puts the value onto the screen
					while( BusyXLCD() );				
					LCD_blank_end();			
					break;

				default:	// The default case would be to show an error

					SetDDRamAddr( 0x03 );		// Put the cursor in the correct position
					while(BusyXLCD());
					putrsXLCD(Error_text);			// Puts the '**ERROR**' onto the screen
					while(BusyXLCD());
					LCD_blank_end();
					break;
				}
			//*******Here is where we update the SPI display with required value****//
			//** This is set in the user.c header **********************************//

			switch(SPIdisplayflag)
			{
				case 0:
					// This case displays the POWER
					MAX7219Clear();  // First clear the display
					// The Power_out value is in the from XXXX which equates to XX.XX
					// This needs to be filtered t the useful data ie. XX.X
					// Hence we divide by 10 and then put the decimal point into it
					if(Power_out<=9)	
					{
						// This is for values less than 0.1W
						MAX7219Write(5,0x00);
						MAX7219Write(4,0x80); // This shows "0.0" on the SPI display
					}
					else if(Power_out<=99)
					{
						// This is for values from 0.1W to 0.99W
						MAX7219WriteValue((Power_out/10));
						MAX7219Write(4,0x80); // This shows "0.X" on the SPI display

					}
					else
					{	
						// This is for values above 1.0W
						MAX7219WriteValueDP((Power_out/10),4);	
					}
					break;

				case 1:  

					if(hold_values==FALSE) // Only do any of the display if the values are not held
					{
						MAX7219Clear();  // First clear the display
						// This case displays the ENERGY
						// The Power_out value is in the from XXXX which equates to XX.XX
						// This needs to be filtered t the useful data ie. XX.X
						// Hence we divide by 10 and then put the decimal point into it
						if(Energy_out_Wh*100<1)	
						{
							// This is for values less than 0.01Wh
							MAX7219Write(5,0x00);
							MAX7219Write(4,0x00);
							MAX7219Write(3,0x80); // This shows "0.00" on the SPI display
						}
						else if(Energy_out_Wh*100<10)
						{
							// This is for values from 0.01W to 0.09Wh
							MAX7219WriteValue((Energy_out_Wh*100));
							MAX7219Write(4,0x00);
							MAX7219Write(3,0x80); // This shows "0.0X" on the SPI display
	
						}
						else if(Energy_out_Wh*100<99)
						{
							// This is for values from 0.1W to 0.99Wh
							MAX7219WriteValue((Energy_out_Wh*100));
							MAX7219Write(3,0x80); // This shows "0.X" on the SPI display
	
						}
						else
						{	
							// This is for values above 1.0Wh
							MAX7219WriteValueDP((Energy_out_Wh*100),3);	
						}
					}
					break;

				case 2:
					// This case displays the TEST COUNTER
					MAX7219Clear();  // First clear the display

					MAX7219WriteValue(TEST_COUNT);
					TEST_COUNT++;

					break;

				default:
					// This is in case there is an error - displays the SPIdisplayflag value
					MAX7219WriteValue(SPIdisplayflag);				
					break;

			}			

			//**************end of sorting out the SPI*****************************//
			
			update_display=FALSE;	//Wait until it is set again		

		}



		//***********These values reset all counters and interrupt flags etc********//
		T2CON = 0b00000111;  		// Initialise TIMER2
		PIR1bits.TMR2IF = 0; 		// Clear the TIMER2 interrupt 
		INTCONbits.GIEL = 1;		// Interrupt control register: Enable Low P Interrupt Enable bit
		//**************** END OF THE LOW PRIORITY INTERRUPT ROUTINE *************//
	}	//This return will be a "retfie", since this is in a #pragma interruptlow section 

#endif


/** DECLARATIONS ***************************************************/
#pragma code

/******************************************************************************
 * Function:        void main(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        Main program entry point.
 *
 * Note:            None
 *******************************************************************/

#if defined(__18CXX)
void main(void)
#else
int main(void)
#endif
{   
    InitializeSystem();

    #if defined(USB_INTERRUPT)
        USBDeviceAttach();
    #endif

    while(1)
    {		
        #if defined(USB_POLLING)
		// Check bus status and service USB interrupts.
        USBDeviceTasks(); // Interrupt or polling method.  If using polling, must call
        				  // this function periodically.  This function will take care
        				  // of processing and responding to SETUP transactions 
        				  // (such as during the enumeration process when you first
        				  // plug in).  USB hosts require that USB devices should accept
        				  // and process SETUP packets in a timely fashion.  Therefore,
        				  // when using polling, this function should be called 
        				  // frequently (such as once about every 100 microseconds) at any
        				  // time that a SETUP packet might reasonably be expected to
        				  // be sent by the host to your device.  In most cases, the
        				  // USBDeviceTasks() function does not take very long to
        				  // execute (~50 instruction cycles) before it returns.
        #endif

		// **************Application-specific tasks***********************************
		// Application related code may be added here, or in the ProcessIO() function.
        ProcessIO();      

    }//end while
}//end main


/********************************************************************
 * Function:        static void InitializeSystem(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        InitializeSystem is a centralize initialization
 *                  routine. All required USB initialization routines
 *                  are called from here.
 *
 *                  User application initialization routine should
 *                  also be called from here.                  
 *
 * Note:            None
 *******************************************************************/
static void InitializeSystem(void)
{
    #if (defined(__18CXX) & !defined(PIC18F87J50_PIM))
        ADCON1 |= 0x0F;                 // Default all pins to digital
    #endif
    
//	The USB specifications require that USB peripheral devices must never source
//	current onto the Vbus pin.  Additionally, USB peripherals should not source
//	current on D+ or D- when the host/hub is not actively powering the Vbus line.
//	When designing a self powered (as opposed to bus powered) USB peripheral
//	device, the firmware should make sure not to turn on the USB module and D+
//	or D- pull up resistor unless Vbus is actively powered.  Therefore, the
//	firmware needs some means to detect when Vbus is being powered by the host.
//	A 5V tolerant I/O pin can be connected to Vbus (through a resistor), and
// 	can be used to detect when Vbus is high (host actively powering), or low
//	(host is shut down or otherwise not supplying power).  The USB firmware
// 	can then periodically poll this I/O pin to know when it is okay to turn on
//	the USB module/D+/D- pull up resistor.  When designing a purely bus powered
//	peripheral device, it is not possible to source current on D+ or D- when the
//	host is not actively providing power on Vbus. Therefore, implementing this
//	bus sense feature is optional.  This firmware can be made to use this bus
//	sense feature by making sure "USE_USB_BUS_SENSE_IO" has been defined in the
//	HardwareProfile.h file.    
    #if defined(USE_USB_BUS_SENSE_IO)
    tris_usb_bus_sense = INPUT_PIN; // See HardwareProfile.h
    #endif
//    
//	If the host PC sends a GetStatus (device) request, the firmware must respond
//	and let the host know if the USB peripheral device is currently bus powered
//	or self powered.  See chapter 9 in the official USB specifications for details
//	regarding this request.  If the peripheral device is capable of being both
//	self and bus powered, it should not return a hard coded value for this request.
//	Instead, firmware should check if it is currently self or bus powered, and
//	respond accordingly.  If the hardware has been configured like demonstrated
//	on the PICDEM FS USB Demo Board, an I/O pin can be polled to determine the
//	currently selected power source.  On the PICDEM FS USB Demo Board, "RA2" 
//	is used for	this purpose.  If using this feature, make sure "USE_SELF_POWER_SENSE_IO"
//	has been defined in HardwareProfile - (platform).h, and that an appropriate I/O pin 
//  has been mapped	to it.
    #if defined(USE_SELF_POWER_SENSE_IO)
    tris_self_power = INPUT_PIN;	// See HardwareProfile
    #endif
    
	UserInit();

	USBDeviceInit();	//usb_device.c.  Initializes USB module SFRs and firmware
    					// variables to known states.

}//end InitializeSystem

// ******************************************************************************************************
// ************** USB Callback Functions ****************************************************************
// ******************************************************************************************************
// The USB firmware stack will call the callback functions USBCBxxx() in response to certain USB related
// events.  For example, if the host PC is powering down, it will stop sending out Start of Frame (SOF)
// packets to your device.  In response to this, all USB devices are supposed to decrease their power
// consumption from the USB Vbus to <2.5mA each.  The USB module detects this condition (which according
// to the USB specifications is 3+ms of no bus activity/SOF packets) and then calls the USBCBSuspend()
// function.  You should modify these callback functions to take appropriate actions for each of these
// conditions.  For example, in the USBCBSuspend(), you may wish to add code that will decrease power
// consumption from Vbus to <2.5mA (such as by clock switching, turning off LEDs, putting the
// microcontroller to sleep, etc.).  Then, in the USBCBWakeFromSuspend() function, you may then wish to
// add code that undoes the power saving things done in the USBCBSuspend() function.

// The USBCBSendResume() function is special, in that the USB stack will not automatically call this
// function.  This function is meant to be called from the application firmware instead.  See the
// additional comments near the function.

/******************************************************************************
 * Function:        void USBCBSuspend(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        Call back that is invoked when a USB suspend is detected
 *
 * Note:            None
 *****************************************************************************/
void USBCBSuspend(void)
{
	//Example power saving code.  Insert appropriate code here for the desired
	//application behavior.  If the microcontroller will be put to sleep, a
	//process similar to that shown below may be used:
	
	//ConfigureIOPinsForLowPower();
	//SaveStateOfAllInterruptEnableBits();
	//DisableAllInterruptEnableBits();
	//EnableOnlyTheInterruptsWhichWillBeUsedToWakeTheMicro();	//should enable at least USBActivityIF as a wake source
	//Sleep();
	//RestoreStateOfAllPreviouslySavedInterruptEnableBits();	//Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.
	//RestoreIOPinsToNormal();									//Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.

	//IMPORTANT NOTE: Do not clear the USBActivityIF (ACTVIF) bit here.  This bit is 
	//cleared inside the usb_device.c file.  Clearing USBActivityIF here will cause 
	//things to not work as intended.	
	

    #if defined(__C30__)
    #if 0
        U1EIR = 0xFFFF;
        U1IR = 0xFFFF;
        U1OTGIR = 0xFFFF;
        IFS5bits.USB1IF = 0;
        IEC5bits.USB1IE = 1;
        U1OTGIEbits.ACTVIE = 1;
        U1OTGIRbits.ACTVIF = 1;
        Sleep();
    #endif
    #endif
}


/******************************************************************************
 * Function:        void _USB1Interrupt(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        This function is called when the USB interrupt bit is set
 *					In this example the interrupt is only used when the device
 *					goes to sleep when it receives a USB suspend command
 *
 * Note:            None
 *****************************************************************************/
#if 0
void __attribute__ ((interrupt)) _USB1Interrupt(void)
{
    #if !defined(self_powered)
        if(U1OTGIRbits.ACTVIF)
        {
            IEC5bits.USB1IE = 0;
            U1OTGIEbits.ACTVIE = 0;
            IFS5bits.USB1IF = 0;
        
            //USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
            USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
            //USBSuspendControl = 0;
        }
    #endif
}
#endif

/******************************************************************************
 * Function:        void USBCBWakeFromSuspend(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        The host may put USB peripheral devices in low power
 *					suspend mode (by "sending" 3+ms of idle).  Once in suspend
 *					mode, the host may wake the device back up by sending non-
 *					idle state signalling.
 *					
 *					This call back is invoked when a wakeup from USB suspend 
 *					is detected.
 *
 * Note:            None
 *****************************************************************************/
void USBCBWakeFromSuspend(void)
{
	// If clock switching or other power savings measures were taken when
	// executing the USBCBSuspend() function, now would be a good time to
	// switch back to normal full power run mode conditions.  The host allows
	// a few milliseconds of wakeup time, after which the device must be 
	// fully back to normal, and capable of receiving and processing USB
	// packets.  In order to do this, the USB module must receive proper
	// clocking (IE: 48MHz clock must be available to SIE for full speed USB
	// operation).
}

/********************************************************************
 * Function:        void USBCB_SOF_Handler(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        The USB host sends out a SOF packet to full-speed
 *                  devices every 1 ms. This interrupt may be useful
 *                  for isochronous pipes. End designers should
 *                  implement callback routine as necessary.
 *
 * Note:            None
 *******************************************************************/
void USBCB_SOF_Handler(void)
{
    // No need to clear UIRbits.SOFIF to 0 here.
    // Callback caller is already doing that.
}

/*******************************************************************
 * Function:        void USBCBErrorHandler(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        The purpose of this callback is mainly for
 *                  debugging during development. Check UEIR to see
 *                  which error causes the interrupt.
 *
 * Note:            None
 *******************************************************************/
void USBCBErrorHandler(void)
{
    // No need to clear UEIR to 0 here.
    // Callback caller is already doing that.

	// Typically, user firmware does not need to do anything special
	// if a USB error occurs.  For example, if the host sends an OUT
	// packet to your device, but the packet gets corrupted (ex:
	// because of a bad connection, or the user unplugs the
	// USB cable during the transmission) this will typically set
	// one or more USB error interrupt flags.  Nothing specific
	// needs to be done however, since the SIE will automatically
	// send a "NAK" packet to the host.  In response to this, the
	// host will normally retry to send the packet again, and no
	// data loss occurs.  The system will typically recover
	// automatically, without the need for application firmware
	// intervention.
	
	// Nevertheless, this callback function is provided, such as
	// for debugging purposes.
}


/*******************************************************************
 * Function:        void USBCBCheckOtherReq(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        When SETUP packets arrive from the host, some
 * 					firmware must process the request and respond
 *					appropriately to fulfill the request.  Some of
 *					the SETUP packets will be for standard
 *					USB "chapter 9" (as in, fulfilling chapter 9 of
 *					the official USB specifications) requests, while
 *					others may be specific to the USB device class
 *					that is being implemented.  For example, a HID
 *					class device needs to be able to respond to
 *					"GET REPORT" type of requests.  This
 *					is not a standard USB chapter 9 request, and 
 *					therefore not handled by usb_device.c.  Instead
 *					this request should be handled by class specific 
 *					firmware, such as that contained in usb_function_hid.c.
 *
 * Note:            None
 *****************************************************************************/
void USBCBCheckOtherReq(void)
{
}//end


/*******************************************************************
 * Function:        void USBCBStdSetDscHandler(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        The USBCBStdSetDscHandler() callback function is
 *					called when a SETUP, bRequest: SET_DESCRIPTOR request
 *					arrives.  Typically SET_DESCRIPTOR requests are
 *					not used in most applications, and it is
 *					optional to support this type of request.
 *
 * Note:            None
 *****************************************************************************/
void USBCBStdSetDscHandler(void)
{
    // Must claim session ownership if supporting this request
}//end


/******************************************************************************
 * Function:        void USBCBInitEP(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        This function is called when the device becomes
 *                  initialized, which occurs after the host sends a
 * 					SET_CONFIGURATION (wValue not = 0) request.  This 
 *					callback function should initialize the endpoints 
 *					for the device's usage according to the current 
 *					configuration.
 *
 * Note:            None
 *****************************************************************************/
void USBCBInitEP(void)
{
    USBEnableEndpoint(USBGEN_EP_NUM,USB_OUT_ENABLED|USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
    USBGenericOutHandle = USBGenRead(USBGEN_EP_NUM,(BYTE*)&OUTPacket,USBGEN_EP_SIZE);
}

/********************************************************************
 * Function:        void USBCBSendResume(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        The USB specifications allow some types of USB
 * 					peripheral devices to wake up a host PC (such
 *					as if it is in a low power suspend to RAM state).
 *					This can be a very useful feature in some
 *					USB applications, such as an Infrared remote
 *					control	receiver.  If a user presses the "power"
 *					button on a remote control, it is nice that the
 *					IR receiver can detect this signalling, and then
 *					send a USB "command" to the PC to wake up.
 *					
 *					The USBCBSendResume() "callback" function is used
 *					to send this special USB signalling which wakes 
 *					up the PC.  This function may be called by
 *					application firmware to wake up the PC.  This
 *					function should only be called when:
 *					
 *					1.  The USB driver used on the host PC supports
 *						the remote wakeup capability.
 *					2.  The USB configuration descriptor indicates
 *						the device is remote wakeup capable in the
 *						bmAttributes field.
 *					3.  The USB host PC is currently sleeping,
 *						and has previously sent your device a SET 
 *						FEATURE setup packet which "armed" the
 *						remote wakeup capability.   
 *
 *					This callback should send a RESUME signal that
 *                  has the period of 1-15ms.
 *
 * Note:            Interrupt vs. Polling
 *                  -Primary clock
 *                  -Secondary clock ***** MAKE NOTES ABOUT THIS *******
 *                   > Can switch to primary first by calling USBCBWakeFromSuspend()
 
 *                  The modifiable section in this routine should be changed
 *                  to meet the application needs. Current implementation
 *                  temporary blocks other functions from executing for a
 *                  period of 1-13 ms depending on the core frequency.
 *
 *                  According to USB 2.0 specification section 7.1.7.7,
 *                  "The remote wakeup device must hold the resume signaling
 *                  for at lest 1 ms but for no more than 15 ms."
 *                  The idea here is to use a delay counter loop, using a
 *                  common value that would work over a wide range of core
 *                  frequencies.
 *                  That value selected is 1800. See table below:
 *                  ==========================================================
 *                  Core Freq(MHz)      MIP         RESUME Signal Period (ms)
 *                  ==========================================================
 *                      48              12          1.05
 *                       4              1           12.6
 *                  ==========================================================
 *                  * These timing could be incorrect when using code
 *                    optimization or extended instruction mode,
 *                    or when having other interrupts enabled.
 *                    Make sure to verify using the MPLAB SIM's Stopwatch
 *                    and verify the actual signal on an oscilloscope.
 *******************************************************************/
void USBCBSendResume(void)
{
    static WORD delay_count;
    
    USBResumeControl = 1;                // Start RESUME signaling
    
    delay_count = 1800U;                // Set RESUME line for 1-13 ms
    do
    {
        delay_count--;
    }while(delay_count);
    USBResumeControl = 0;
}


/*******************************************************************
 * Function:        BOOL USER_USB_CALLBACK_EVENT_HANDLER(
 *                        USB_EVENT event, void *pdata, WORD size)
 *
 * PreCondition:    None
 *
 * Input:           USB_EVENT event - the type of event
 *                  void *pdata - pointer to the event data
 *                  WORD size - size of the event data
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        This function is called from the USB stack to
 *                  notify a user application that a USB event
 *                  occured.  This callback is in interrupt context
 *                  when the USB_INTERRUPT option is selected.
 *
 * Note:            None
 *******************************************************************/
BOOL USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, WORD size)
{
    switch(event)
    {
        case EVENT_CONFIGURED: 
            USBCBInitEP();
            break;
        case EVENT_SET_DESCRIPTOR:
            USBCBStdSetDscHandler();
            break;
        case EVENT_EP0_REQUEST:
            USBCBCheckOtherReq();
            break;
        case EVENT_SOF:
            USBCB_SOF_Handler();
            break;
        case EVENT_SUSPEND:
            USBCBSuspend();
            break;
        case EVENT_RESUME:
            USBCBWakeFromSuspend();
            break;
        case EVENT_BUS_ERROR:
            USBCBErrorHandler();
            break;
        case EVENT_TRANSFER:
            Nop();
            break;
        default:
            break;
    }      
    return TRUE; 
}


/******************************************************************************
 * Function:        void ConvertIntStr(char )
 *
 * PreCondition:    None
 *
 * Input:           intstr, digits
 *
 * Output:          char string
 *
 * Side Effects:    None
 *
 * Overview:        This function takes in an integer and returns a pointer to a string 
 *					The string will show the data as XXX.X with the number of decimal points also given
 *					Send a string and a number of digits after the decimal point (0,1,2)				
 *
 * Note:            None
 *****************************************************************************/

char* ConvertIntStr(long int intstr, int digits)
{
//********routine to convert int into a string in the format XXXXX.X is below***************
//********routine does not care how long the number is****************************************

	
	ltoa(intstr, string);					// Convert long into a string
	lengthres=strlen(string);				// Check the length of the data

	if(lengthres==1)						// Should never get a negative reading with a length of 1 
	{										// Display 0.0			
		strcpypgm2ram(result,zero);			// These IF statements  and 'pad' it out with 0's
		strcatpgm2ram(result,zero);
		strcat(result,string);
			
		lengthres=3;
	}
	else if(lengthres==2)					// This is a special case
	{
		if(ispunct(string[0])==0)				// Problem if a negative number is sent to the routine.		
		{
			strcpypgm2ram(result,zero);			// Display 0.X
			strcat(result,string);
			lengthres=3;
		}
		else
		{
			presult = string + 1;				// Get the pointer to the last bit of data
			strcpypgm2ram(result,null);			// Display -0.0
			strncat(result,string,1);			// Add the - ve sign	
			strcatpgm2ram(result,zero);			// The add in a zero
			strcatpgm2ram(result,zero);			// The add in another zero
			strcat(result,presult);
			lengthres=4;		
		}
	}
	else if(lengthres==3)					// This is a special case
	{
		if(ispunct(string[0])==0)			// If positive then:		
		{
			strcpy(result,string);			// Display X.X
		}
		else									// If negative then:	
		{
			presult = string + 1;				// Get the pointer to the last bit of data
			strcpypgm2ram(result,null);			// Display -0.X
			strncat(result,string,1);			// Add the - ve sign	
			strcatpgm2ram(result,zero);			// Then add in a zero
			strcat(result,presult);				// Then add the value (the decimal point is added later)
			lengthres=4;					
		}
	}
	else
	{
		strcpy(result,string);
	}

	presult = result + (lengthres-2);		// Get the pointer to the last bit of data

	strcpypgm2ram(result2,null);			// The add the null value to start the array
	strncat(result2,result,(lengthres-2));	// Get the main chunk of data
	if(digits==1)
	{
		strcatpgm2ram(result2,decimalpt);	// The add in a decimal point	
		strncat(result2,presult,1);				// Then end with the last value
	}
	if(digits==2)
	{
		strcatpgm2ram(result2,decimalpt);	// The add in a decimal point	
		strncat(result2,presult,2);				// Then end with the last value
	}	
	strcatpgm2ram(result2,null);			// The add the null value
			
	return(result2);
}

/******************************************************************************
 * Function:        void ConvertSecondsStr(char )
 *
 * PreCondition:    None
 *
 * Input:           intstr
 *
 * Output:          char string
 *
 * Side Effects:    None
 *
 * Overview:        This function takes in the long integer containing a run time is seconds
 *					It converts that value into a string containing XXXXXXh XXm XXs				
 *					A pointer to this value is returned
 *	
 * Note:            None
 *****************************************************************************/

char* ConvertSecondStr(unsigned long int intstr)
{	
	long int hours=0;
	int mins=0;
	int seconds=0;
	char stringhr[7];
	char stringmin[3];
	char stringsec[3];

	hours = intstr/3600;	
	mins = (intstr-(hours*3600))/60;
	seconds = intstr-(hours*3600)-(mins*60);

	ltoa(hours, stringhr);				// Convert long into a string
	ltoa(mins, stringmin);				// Convert long into a string
	ltoa(seconds, stringsec);			// Convert long into a string

	strcpypgm2ram(result,null);			
	strcat(result,stringhr);				// Add the hour value	
	strcatpgm2ram(result,Time_unit_h);		// Add the hour unit
	strcat(result,stringmin);				// Add the hour value	
	strcatpgm2ram(result,Time_unit_m);		// Add the hour unit
	strcat(result,stringsec);				// Add the hour value	
	strcatpgm2ram(result,Time_unit_s);		// Add the hour unit

	return(result);
}

/******************************************************************************
 * Function:        void ConvertTimeStr(char )
 *
 * PreCondition:    None
 *
 * Input:           intstr
 *
 * Output:          char string
 *
 * Side Effects:    None
 *
 * Overview:        Thus takes in the seconds value of time and converts to a string
 *					Nthin clever happens in the rutine...
 *	
 * Note:            None
 *****************************************************************************/

char* ConvertTimeStr(unsigned long int intstr)
{	

	ltoa(intstr, string);				// Convert long into a string

	strcpypgm2ram(result,null);			
	strcat(result,string);				// Add the number value

	return(result);
}


/******************************************************************************
 * Function:        void ConvertkWhtodisplay(char, int )
 *
 * PreCondition:    None
 *
 * Input:           intstr, digits
 *
 * Output:          char string
 *
 * Side Effects:    None
 *
 * Overview:        What does it do???...?			
 *
 * Note:            None
 *****************************************************************************/
char* ConvertkWhtodisplay(long int Wh_value)
{

}



/******************************************************************************
 * Function:        void cursor_0_space(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        This sets the cursor to the correct place (set in 0 from the end) and blanks the first char	
 *
 * Note:            
 *****************************************************************************/
void cursor_0_space(void)
{
	SetDDRamAddr( 0x00 );		// Put the cursor in the correct position
	while(BusyXLCD());
}

/******************************************************************************
 * Function:        void cursor_1_space(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        This sets the cursor to the correct place (set in 1 from the end) and blanks the first char	
 *
 * Note:            
 *****************************************************************************/
void cursor_1_space(void)
{
	SetDDRamAddr( 0x00 );		// Put the cursor in the correct position
	while(BusyXLCD());
	putcXLCD(' ');					// Blank out any unused bits 
	while(BusyXLCD());
}

/******************************************************************************
 * Function:        void LCD_blank_end(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        This blanks all the chars on LCD from LCDaddr to space 16
 *
 * Note:            
 *****************************************************************************/
void LCD_blank_end(void)
{
	addr = ReadAddrXLCD();				// This finds the address to know to blank the other bits			
	for	(n=0;n<(16-addr);n++)
	{
		while(BusyXLCD());
		putcXLCD(' ');					// Blank out any unused bits 
	}
	while(BusyXLCD());
}

/** EOF main.c ***************************************************************/
